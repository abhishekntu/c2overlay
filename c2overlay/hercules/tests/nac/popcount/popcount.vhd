-- File automatically generated by "cdfg2hdl".
-- Filename: popcount.vhd
-- Date: 31 May 2013 12:17:56 PM
-- Author: Nikolaos Kavvadias (C) 2009, 2010, 2011, 2012, 2013

library IEEE;
use WORK.operpack.all;
use WORK.popcount_cdt_pkg.all;
use WORK.std_logic_1164_tinyadditions.all;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;


entity popcount is
  port (
    clk : in std_logic;
    reset : in std_logic;
    start : in std_logic;
    inp : in std_logic_vector(31 downto 0);
    outp : out std_logic_vector(31 downto 0);
    done : out std_logic;
    ready : out std_logic
  );
end popcount;

architecture fsmd of popcount is
  type state_type is (S_ENTRY, S_EXIT, S_001_001, S_001_002, S_001_003, S_002_001, S_002_002, S_002_003, S_002_004, S_003_001);
  signal current_state, next_state: state_type;
  signal count_21_next : std_logic_vector(31 downto 0);
  signal count_21_reg : std_logic_vector(31 downto 0);
  signal count_21_eval : std_logic_vector(31 downto 0);
  signal temp_21_next : std_logic_vector(31 downto 0);
  signal temp_21_reg : std_logic_vector(31 downto 0);
  signal temp_21_eval : std_logic_vector(31 downto 0);
  signal count_11_next : std_logic_vector(31 downto 0);
  signal count_11_reg : std_logic_vector(31 downto 0);
  signal count_11_eval : std_logic_vector(31 downto 0);
  signal data_11_next : std_logic_vector(31 downto 0);
  signal data_11_reg : std_logic_vector(31 downto 0);
  signal data_11_eval : std_logic_vector(31 downto 0);
  signal data_next : std_logic_vector(31 downto 0);
  signal data_reg : std_logic_vector(31 downto 0);
  signal data_eval : std_logic_vector(31 downto 0);
  signal count_next : std_logic_vector(31 downto 0);
  signal count_reg : std_logic_vector(31 downto 0);
  signal count_eval : std_logic_vector(31 downto 0);
  signal data_21_next : std_logic_vector(31 downto 0);
  signal data_21_reg : std_logic_vector(31 downto 0);
  signal data_21_eval : std_logic_vector(31 downto 0);
  signal outp_next : std_logic_vector(31 downto 0);
  signal outp_reg : std_logic_vector(31 downto 0);
  signal outp_eval : std_logic_vector(31 downto 0);
  constant CNST_0 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000000000000000";
  constant CNST_1 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000000000000001";
begin
  -- current state logic
  process (clk, reset)
  begin
    if (reset = '1') then
      current_state <= S_ENTRY;
      count_21_reg <= (others => '0');
      temp_21_reg <= (others => '0');
      count_11_reg <= (others => '0');
      data_11_reg <= (others => '0');
      data_reg <= (others => '0');
      count_reg <= (others => '0');
      data_21_reg <= (others => '0');
      outp_reg <= (others => '0');
    elsif (clk = '1' and clk'EVENT) then
      current_state <= next_state;
      count_21_reg <= count_21_next;
      temp_21_reg <= temp_21_next;
      count_11_reg <= count_11_next;
      data_11_reg <= data_11_next;
      data_reg <= data_next;
      count_reg <= count_next;
      data_21_reg <= data_21_next;
      outp_reg <= outp_next;
    end if;
  end process;

  -- next state and output logic
  process (current_state, start,
    inp,
    outp_reg,
    count_21_reg, count_21_next,
    temp_21_reg, temp_21_next,
    count_11_reg, count_11_next,
    data_11_reg, data_11_next,
    data_reg, data_next,
    count_reg, count_next,
    data_21_reg, data_21_next
  )
  begin
    done <= '0';
    ready <= '0';
    count_21_next <= count_21_reg;
    temp_21_next <= temp_21_reg;
    count_11_next <= count_11_reg;
    data_11_next <= data_11_reg;
    data_next <= data_reg;
    count_next <= count_reg;
    data_21_next <= data_21_reg;
    outp_next <= outp_reg;
    case current_state is
      when S_ENTRY =>
        ready <= '1';
        if (start = '1') then
          next_state <= S_001_001;
        else
          next_state <= S_ENTRY;
        end if;
      when S_001_001 =>
        count_11_next <= CNST_0(31 downto 0);
        data_11_next <= inp(31 downto 0);
        data_next <= data_11_next (31 downto 0);
        count_next <= count_11_next (31 downto 0);
        next_state <= S_002_001; --
      when S_002_001 =>        --
        temp_21_next <= data_reg and CNST_1(31 downto 0);
        data_21_next <= "0" & data_reg(31 downto 1);
        count_21_next <= std_logic_vector(unsigned(count_reg) + unsigned(temp_21_next (31 downto 0)));
        data_next <= data_21_next (31 downto 0);
        count_next <= count_21_next (31 downto 0);
        if (data_21_next  = CNST_0(31 downto 0)) then
          next_state <= S_003_001;
        else
          next_state <= S_002_001;
        end if;
      when S_003_001 =>
        outp_next <= count_reg(31 downto 0);
        next_state <= S_EXIT; --
      when S_EXIT =>        --
        done <= '1';
        next_state <= S_ENTRY;
      when others =>
        next_state <= S_ENTRY;
    end case;
  end process;

  outp <= outp_reg;

end fsmd;
