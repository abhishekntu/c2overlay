-- File automatically generated by "cdfg2hdl".
-- Filename: gcd.vhd
-- Date: 30 May 2013 11:54:34 PM
-- Author: Nikolaos Kavvadias (C) 2009, 2010, 2011, 2012, 2013

library IEEE;
use WORK.operpack.all;
use WORK.gcd_cdt_pkg.all;
use WORK.std_logic_1164_tinyadditions.all;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;


entity gcd is
  port (
    clk : in std_logic;
    reset : in std_logic;
    start : in std_logic;
    a : in std_logic_vector(15 downto 0);
    b : in std_logic_vector(15 downto 0);
    outp : out std_logic_vector(15 downto 0);
    done : out std_logic;
    ready : out std_logic
  );
end gcd;

architecture fsmd of gcd is
  type state_type is (S_ENTRY, S_EXIT, S_001_001, S_001_002, S_001_003, S_001_004, S_002_001, S_003_001, S_004_001, S_004_002, S_004_003, S_005_001, S_005_002, S_005_003, S_006_001, S_006_002, S_006_003, S_007_001);
  signal current_state, next_state: state_type;
  signal t3_1_next : std_logic_vector(15 downto 0);
  signal t3_1_reg : std_logic_vector(15 downto 0);
  signal t3_1_eval : std_logic_vector(15 downto 0);
  signal res_1_next : std_logic_vector(15 downto 0);
  signal res_1_reg : std_logic_vector(15 downto 0);
  signal res_1_eval : std_logic_vector(15 downto 0);
  signal x_1_next : std_logic_vector(15 downto 0);
  signal x_1_reg : std_logic_vector(15 downto 0);
  signal x_1_eval : std_logic_vector(15 downto 0);
  signal res_next : std_logic_vector(15 downto 0);
  signal res_reg : std_logic_vector(15 downto 0);
  signal res_eval : std_logic_vector(15 downto 0);
  signal x_next : std_logic_vector(15 downto 0);
  signal x_reg : std_logic_vector(15 downto 0);
  signal x_eval : std_logic_vector(15 downto 0);
  signal y_next : std_logic_vector(15 downto 0);
  signal y_reg : std_logic_vector(15 downto 0);
  signal y_eval : std_logic_vector(15 downto 0);
  signal y_1_next : std_logic_vector(15 downto 0);
  signal y_1_reg : std_logic_vector(15 downto 0);
  signal y_1_eval : std_logic_vector(15 downto 0);
  signal t1_1_next : std_logic_vector(15 downto 0);
  signal t1_1_reg : std_logic_vector(15 downto 0);
  signal t1_1_eval : std_logic_vector(15 downto 0);
  signal t2_1_next : std_logic_vector(15 downto 0);
  signal t2_1_reg : std_logic_vector(15 downto 0);
  signal t2_1_eval : std_logic_vector(15 downto 0);
  signal outp_next : std_logic_vector(15 downto 0);
  signal outp_reg : std_logic_vector(15 downto 0);
  signal outp_eval : std_logic_vector(15 downto 0);
  constant CNST_0 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000000000000000";
  constant CNST_1 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000000000000001";
begin
  -- current state logic
  process (clk, reset)
  begin
    if (reset = '1') then
      current_state <= S_ENTRY;
      t3_1_reg <= (others => '0');
      res_1_reg <= (others => '0');
      x_1_reg <= (others => '0');
      res_reg <= (others => '0');
      x_reg <= (others => '0');
      y_reg <= (others => '0');
      y_1_reg <= (others => '0');
      t1_1_reg <= (others => '0');
      t2_1_reg <= (others => '0');
      outp_reg <= (others => '0');
    elsif (clk = '1' and clk'EVENT) then
      current_state <= next_state;
      t3_1_reg <= t3_1_next;
      res_1_reg <= res_1_next;
      x_1_reg <= x_1_next;
      res_reg <= res_next;
      x_reg <= x_next;
      y_reg <= y_next;
      y_1_reg <= y_1_next;
      t1_1_reg <= t1_1_next;
      t2_1_reg <= t2_1_next;
      outp_reg <= outp_next;
    end if;
  end process;

  -- next state and output logic
  process (current_state, start,
    a,
    b,
    outp_reg,
    t3_1_reg, t3_1_next,
    res_1_reg, res_1_next,
    x_1_reg, x_1_next,
    res_reg, res_next,
    x_reg, x_next,
    y_reg, y_next,
    y_1_reg, y_1_next,
    t1_1_reg, t1_1_next,
    t2_1_reg, t2_1_next
  )
  begin
    done <= '0';
    ready <= '0';
    t3_1_next <= t3_1_reg;
    res_1_next <= res_1_reg;
    x_1_next <= x_1_reg;
    res_next <= res_reg;
    x_next <= x_reg;
    y_next <= y_reg;
    y_1_next <= y_1_reg;
    t1_1_next <= t1_1_reg;
    t2_1_next <= t2_1_reg;
    outp_next <= outp_reg;
    case current_state is
      when S_ENTRY =>
        ready <= '1';
        if (start = '1') then
          next_state <= S_001_001;
        else
          next_state <= S_ENTRY;
        end if;
      when S_001_001 =>
        res_1_next <= CNST_0(15 downto 0);
        x_1_next <= a(15 downto 0);
        y_1_next <= b(15 downto 0);
        x_next <= x_1_next (15 downto 0);
        y_next <= y_1_next (15 downto 0);
        res_next <= res_1_next (15 downto 0);
        if (x_1_next  /= CNST_0(15 downto 0)) then
          t1_1_next <= "0000000000000001";
        else
          t1_1_next <= (others => '0');
        end if;
        if (y_1_next  /= CNST_0(15 downto 0)) then
          t2_1_next <= "0000000000000001";
        else
          t2_1_next <= (others => '0');
        end if;
        t3_1_next <= t1_1_next  and t2_1_next (15 downto 0);
        if (t3_1_next  /= CNST_1(15 downto 0)) then
          next_state <= S_007_001;
        else
          next_state <= S_002_001;
        end if;
      when S_002_001 =>
        if (x_reg > y_reg(15 downto 0)) then
          next_state <= S_005_001;
        else
          next_state <= S_003_001;
        end if;
      when S_003_001 =>
        if (x_reg < y_reg(15 downto 0)) then
          next_state <= S_006_001;
        else
          next_state <= S_004_001;
        end if;
      when S_004_001 =>
        res_1_next <= x_reg(15 downto 0);
        res_next <= res_1_next (15 downto 0);
        next_state <= S_007_001;
      when S_005_001 =>
        x_1_next <= std_logic_vector(unsigned(x_reg) - unsigned(y_reg(15 downto 0)));
        x_next <= x_1_next (15 downto 0);
        next_state <= S_002_001;
      when S_006_001 =>
        y_1_next <= std_logic_vector(unsigned(y_reg) - unsigned(x_reg(15 downto 0)));
        y_next <= y_1_next (15 downto 0);
        next_state <= S_002_001;
      when S_007_001 =>
        outp_next <= res_reg(15 downto 0);
        next_state <= S_EXIT; --
      when S_EXIT =>        --
        done <= '1';
        next_state <= S_ENTRY;
      when others =>
        next_state <= S_ENTRY;
    end case;
  end process;

  outp <= outp_reg;

end fsmd;
