-- File automatically generated by "cdfg2hdl".
-- Filename: eda.vhd
-- Date: 31 May 2013 11:08:47 PM
-- Author: Nikolaos Kavvadias (C) 2009, 2010, 2011, 2012, 2013

library IEEE;
use WORK.operpack.all;
use WORK.eda_cdt_pkg.all;
use WORK.std_logic_1164_tinyadditions.all;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;


entity eda is
  port (
    clk : in std_logic;
    reset : in std_logic;
    start : in std_logic;
    in1 : in std_logic_vector(31 downto 0);
    in2 : in std_logic_vector(31 downto 0);
    out1 : out std_logic_vector(31 downto 0);
    done : out std_logic;
    ready : out std_logic
  );
end eda;

architecture fsmd of eda is
  type state_type is (S_ENTRY, S_EXIT, S_001_001, S_001_002, S_001_003, S_001_004, S_001_005, S_001_006, S_001_007);
  signal current_state, next_state: state_type;
  signal t1_11_next : std_logic_vector(31 downto 0);
  signal t1_11_reg : std_logic_vector(31 downto 0);
  signal t1_11_eval : std_logic_vector(31 downto 0);
  signal t2_11_next : std_logic_vector(31 downto 0);
  signal t2_11_reg : std_logic_vector(31 downto 0);
  signal t2_11_eval : std_logic_vector(31 downto 0);
  signal t6_11_next : std_logic_vector(31 downto 0);
  signal t6_11_reg : std_logic_vector(31 downto 0);
  signal t6_11_eval : std_logic_vector(31 downto 0);
  signal x_11_next : std_logic_vector(31 downto 0);
  signal x_11_reg : std_logic_vector(31 downto 0);
  signal x_11_eval : std_logic_vector(31 downto 0);
  signal t7_11_next : std_logic_vector(31 downto 0);
  signal t7_11_reg : std_logic_vector(31 downto 0);
  signal t7_11_eval : std_logic_vector(31 downto 0);
  signal y_11_next : std_logic_vector(31 downto 0);
  signal y_11_reg : std_logic_vector(31 downto 0);
  signal y_11_eval : std_logic_vector(31 downto 0);
  signal t3_11_next : std_logic_vector(31 downto 0);
  signal t3_11_reg : std_logic_vector(31 downto 0);
  signal t3_11_eval : std_logic_vector(31 downto 0);
  signal t4_11_next : std_logic_vector(31 downto 0);
  signal t4_11_reg : std_logic_vector(31 downto 0);
  signal t4_11_eval : std_logic_vector(31 downto 0);
  signal t5_11_next : std_logic_vector(31 downto 0);
  signal t5_11_reg : std_logic_vector(31 downto 0);
  signal t5_11_eval : std_logic_vector(31 downto 0);
  signal out1_next : std_logic_vector(31 downto 0);
  signal out1_reg : std_logic_vector(31 downto 0);
  signal out1_eval : std_logic_vector(31 downto 0);
  constant CNST_1 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000000000000001";
  constant CNST_3 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000000000000011";
begin
  -- current state logic
  process (clk, reset)
  begin
    if (reset = '1') then
      current_state <= S_ENTRY;
      t1_11_reg <= (others => '0');
      t2_11_reg <= (others => '0');
      t6_11_reg <= (others => '0');
      x_11_reg <= (others => '0');
      t7_11_reg <= (others => '0');
      y_11_reg <= (others => '0');
      t3_11_reg <= (others => '0');
      t4_11_reg <= (others => '0');
      t5_11_reg <= (others => '0');
      out1_reg <= (others => '0');
    elsif (clk = '1' and clk'EVENT) then
      current_state <= next_state;
      t1_11_reg <= t1_11_next;
      t2_11_reg <= t2_11_next;
      t6_11_reg <= t6_11_next;
      x_11_reg <= x_11_next;
      t7_11_reg <= t7_11_next;
      y_11_reg <= y_11_next;
      t3_11_reg <= t3_11_next;
      t4_11_reg <= t4_11_next;
      t5_11_reg <= t5_11_next;
      out1_reg <= out1_next;
    end if;
  end process;

  -- next state and output logic
  process (current_state, start,
    in1,
    in2,
    out1_reg,
    t1_11_reg, t1_11_next,
    t2_11_reg, t2_11_next,
    t6_11_reg, t6_11_next,
    x_11_reg, x_11_next,
    t7_11_reg, t7_11_next,
    y_11_reg, y_11_next,
    t3_11_reg, t3_11_next,
    t4_11_reg, t4_11_next,
    t5_11_reg, t5_11_next
  )
  begin
    done <= '0';
    ready <= '0';
    t1_11_next <= t1_11_reg;
    t2_11_next <= t2_11_reg;
    t6_11_next <= t6_11_reg;
    x_11_next <= x_11_reg;
    t7_11_next <= t7_11_reg;
    y_11_next <= y_11_reg;
    t3_11_next <= t3_11_reg;
    t4_11_next <= t4_11_reg;
    t5_11_next <= t5_11_reg;
    out1_next <= out1_reg;
    case current_state is
      when S_ENTRY =>
        ready <= '1';
        if (start = '1') then
          next_state <= S_001_001;
        else
          next_state <= S_ENTRY;
        end if;
      when S_001_001 =>
        if (in1(31) = '1') then
          t1_11_next <= std_logic_vector(not(unsigned(in1(31 downto 0))) + unsigned(ONE));
        else
          t1_11_next <= in1(31 downto 0);
        end if;
        if (in2(31) = '1') then
          t2_11_next <= std_logic_vector(not(unsigned(in2(31 downto 0))) + unsigned(ONE));
        else
          t2_11_next <= in2(31 downto 0);
        end if;
        if (t1_11_next  > t2_11_next (31 downto 0)) then
          x_11_next <= t1_11_next (31 downto 0);
        else
          x_11_next <= t2_11_next (31 downto 0);
        end if;
        if (t1_11_next  < t2_11_next (31 downto 0)) then
          y_11_next <= t1_11_next (31 downto 0);
        else
          y_11_next <= t2_11_next (31 downto 0);
        end if;
        t3_11_next <= "000" & x_11_next (31 downto 3);
        t4_11_next <= "0" & y_11_next (31 downto 1);
        t5_11_next <= std_logic_vector(unsigned(x_11_next ) - unsigned(t3_11_next (31 downto 0)));
        t6_11_next <= std_logic_vector(unsigned(t4_11_next ) + unsigned(t5_11_next (31 downto 0)));
        if (t6_11_next  > x_11_next (31 downto 0)) then
          t7_11_next <= t6_11_next (31 downto 0);
        else
          t7_11_next <= x_11_next (31 downto 0);
        end if;
        out1_next <= t7_11_next (31 downto 0);
        next_state <= S_EXIT; --
      when S_EXIT =>        --
        done <= '1';
        next_state <= S_ENTRY;
      when others =>
        next_state <= S_ENTRY;
    end case;
  end process;

  out1 <= out1_reg;

end fsmd;
