-- File automatically generated by "cdfg2hdl".
-- Filename: fibo.vhd
-- Date: 29 October 2013 04:35:41 PM
-- Author: Nikolaos Kavvadias (C) 2009, 2010, 2011, 2012, 2013

library IEEE;
use WORK.operpack.all;
use WORK.fibo_cdt_pkg.all;
use WORK.std_logic_1164_tinyadditions.all;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;


entity fibo is
  port (
    clk : in std_logic;
    reset : in std_logic;
    start : in std_logic;
    x : in std_logic_vector(31 downto 0);
    D_1236 : out std_logic_vector(31 downto 0);
    done : out std_logic;
    ready : out std_logic
  );
end fibo;

architecture fsmd of fibo is
  type state_type is (S_ENTRY, S_EXIT, S_001_001, S_001_002, S_001_003, S_001_004, S_001_005, S_001_006, S_001_007, S_002_001, S_002_002, S_002_003, S_002_004, S_002_005, S_002_006, S_002_007, S_002_008, S_003_001);
  signal current_state, next_state: state_type;
  signal k_3_next : std_logic_vector(31 downto 0);
  signal k_3_reg : std_logic_vector(31 downto 0);
  signal k_3_eval : std_logic_vector(31 downto 0);
  signal f_3_next : std_logic_vector(31 downto 0);
  signal f_3_reg : std_logic_vector(31 downto 0);
  signal f_3_eval : std_logic_vector(31 downto 0);
  signal f0_1_next : std_logic_vector(31 downto 0);
  signal f0_1_reg : std_logic_vector(31 downto 0);
  signal f0_1_eval : std_logic_vector(31 downto 0);
  signal f1_1_next : std_logic_vector(31 downto 0);
  signal f1_1_reg : std_logic_vector(31 downto 0);
  signal f1_1_eval : std_logic_vector(31 downto 0);
  signal k_1_next : std_logic_vector(31 downto 0);
  signal k_1_reg : std_logic_vector(31 downto 0);
  signal k_1_eval : std_logic_vector(31 downto 0);
  signal f1_3_next : std_logic_vector(31 downto 0);
  signal f1_3_reg : std_logic_vector(31 downto 0);
  signal f1_3_eval : std_logic_vector(31 downto 0);
  signal f0_2_next : std_logic_vector(31 downto 0);
  signal f0_2_reg : std_logic_vector(31 downto 0);
  signal f0_2_eval : std_logic_vector(31 downto 0);
  signal f1_2_next : std_logic_vector(31 downto 0);
  signal f1_2_reg : std_logic_vector(31 downto 0);
  signal f1_2_eval : std_logic_vector(31 downto 0);
  signal k_2_next : std_logic_vector(31 downto 0);
  signal k_2_reg : std_logic_vector(31 downto 0);
  signal k_2_eval : std_logic_vector(31 downto 0);
  signal f0_3_next : std_logic_vector(31 downto 0);
  signal f0_3_reg : std_logic_vector(31 downto 0);
  signal f0_3_eval : std_logic_vector(31 downto 0);
  signal D_1236_next : std_logic_vector(31 downto 0);
  signal D_1236_reg : std_logic_vector(31 downto 0);
  signal D_1236_eval : std_logic_vector(31 downto 0);
  constant CNST_0 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000000000000000";
  constant CNST_1 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000000000000001";
  constant CNST_2 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000000000000010";
begin
  -- current state logic
  process (clk, reset)
  begin
    if (reset = '1') then
      current_state <= S_ENTRY;
      k_3_reg <= (others => '0');
      f_3_reg <= (others => '0');
      f0_1_reg <= (others => '0');
      f1_1_reg <= (others => '0');
      k_1_reg <= (others => '0');
      f1_3_reg <= (others => '0');
      f0_2_reg <= (others => '0');
      f1_2_reg <= (others => '0');
      k_2_reg <= (others => '0');
      f0_3_reg <= (others => '0');
      D_1236_reg <= (others => '0');
    elsif (clk = '1' and clk'EVENT) then
      current_state <= next_state;
      k_3_reg <= k_3_next;
      f_3_reg <= f_3_next;
      f0_1_reg <= f0_1_next;
      f1_1_reg <= f1_1_next;
      k_1_reg <= k_1_next;
      f1_3_reg <= f1_3_next;
      f0_2_reg <= f0_2_next;
      f1_2_reg <= f1_2_next;
      k_2_reg <= k_2_next;
      f0_3_reg <= f0_3_next;
      D_1236_reg <= D_1236_next;
    end if;
  end process;

  -- next state and output logic
  process (current_state, start,
    x,
    D_1236_reg,
    k_3_reg, k_3_next,
    f_3_reg, f_3_next,
    f0_1_reg, f0_1_next,
    f1_1_reg, f1_1_next,
    k_1_reg, k_1_next,
    f1_3_reg, f1_3_next,
    f0_2_reg, f0_2_next,
    f1_2_reg, f1_2_next,
    k_2_reg, k_2_next,
    f0_3_reg, f0_3_next
  )
  begin
    done <= '0';
    ready <= '0';
    k_3_next <= k_3_reg;
    f_3_next <= f_3_reg;
    f0_1_next <= f0_1_reg;
    f1_1_next <= f1_1_reg;
    k_1_next <= k_1_reg;
    f1_3_next <= f1_3_reg;
    f0_2_next <= f0_2_reg;
    f1_2_next <= f1_2_reg;
    k_2_next <= k_2_reg;
    f0_3_next <= f0_3_reg;
    D_1236_next <= D_1236_reg;
    case current_state is
      when S_ENTRY =>
        ready <= '1';
        if (start = '1') then
          next_state <= S_001_001;
        else
          next_state <= S_ENTRY;
        end if;
      when S_001_001 =>
        f0_1_next <= CNST_0(31 downto 0);
        next_state <= S_001_002;
      when S_001_002 =>
        f1_1_next <= CNST_1(31 downto 0);
        next_state <= S_001_003;
      when S_001_003 =>
        k_1_next <= CNST_2(31 downto 0);
        next_state <= S_001_004;
      when S_001_004 =>
        f0_2_next <= f0_1_reg(31 downto 0);
        next_state <= S_001_005;
      when S_001_005 =>
        f1_2_next <= f1_1_reg(31 downto 0);
        next_state <= S_001_006;
      when S_001_006 =>
        k_2_next <= k_1_reg(31 downto 0);
        next_state <= S_001_007;
      when S_001_007 =>
        next_state <= S_002_001;
      when S_002_001 =>
        k_3_next <= std_logic_vector(unsigned(k_2_reg) + unsigned(CNST_1(31 downto 0)));
        next_state <= S_002_002;
      when S_002_002 =>
        f_3_next <= std_logic_vector(unsigned(f1_2_reg) + unsigned(f0_2_reg(31 downto 0)));
        next_state <= S_002_003;
      when S_002_003 =>
        f0_3_next <= f1_2_reg(31 downto 0);
        next_state <= S_002_004;
      when S_002_004 =>
        f1_3_next <= f_3_reg(31 downto 0);
        next_state <= S_002_005;
      when S_002_005 =>
        f0_2_next <= f0_3_reg(31 downto 0);
        next_state <= S_002_006;
      when S_002_006 =>
        f1_2_next <= f1_3_reg(31 downto 0);
        next_state <= S_002_007;
      when S_002_007 =>
        k_2_next <= k_3_reg(31 downto 0);
        next_state <= S_002_008;
      when S_002_008 =>
        if (k_3_reg <= x(31 downto 0)) then
          next_state <= S_002_001;
        else
          next_state <= S_003_001;
        end if;
      when S_003_001 =>
        D_1236_next <= f_3_reg(31 downto 0);
        next_state <= S_EXIT;
      when S_EXIT =>
        done <= '1';
        next_state <= S_ENTRY;
      when others =>
        next_state <= S_ENTRY;
    end case;
  end process;

  D_1236 <= D_1236_reg;

end fsmd;
