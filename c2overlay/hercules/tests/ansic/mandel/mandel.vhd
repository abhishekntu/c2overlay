-- File automatically generated by "cdfg2hdl".
-- Filename: mandel.vhd
-- Date: 12 October 2013 05:11:04 PM
-- Author: Nikolaos Kavvadias (C) 2009, 2010, 2011, 2012, 2013

library IEEE;
use WORK.operpack.all;
use WORK.mandel_cdt_pkg.all;
use WORK.std_logic_1164_tinyadditions.all;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;


entity mandel is
  port (
    clk : in std_logic;
    reset : in std_logic;
    start : in std_logic;
    out1 : out std_logic_vector(31 downto 0);
    done : out std_logic;
    ready : out std_logic
  );
end mandel;

architecture fsmd of mandel is
  type state_type is (S_ENTRY, S_EXIT, S_001_001, S_001_002, S_001_003, S_002_001, S_002_002, S_002_003, S_003_001, S_003_002, S_003_003, S_004_001, S_004_002, S_004_003, S_005_001, S_005_002, S_006_001, S_007_001, S_007_002, S_007_003, S_008_001, S_009_001, S_009_002, S_009_003, S_010_001, S_011_001, S_011_002, S_012_001);
  signal current_state, next_state: state_type;
  signal cnt_41_next : std_logic_vector(31 downto 0);
  signal cnt_41_reg : std_logic_vector(31 downto 0);
  signal cnt_41_eval : std_logic_vector(31 downto 0);
  signal x_71_next : std_logic_vector(31 downto 0);
  signal x_71_reg : std_logic_vector(31 downto 0);
  signal x_71_eval : std_logic_vector(31 downto 0);
  signal on_31_next : std_logic_vector(31 downto 0);
  signal on_31_reg : std_logic_vector(31 downto 0);
  signal on_31_eval : std_logic_vector(31 downto 0);
  signal cnt_11_next : std_logic_vector(31 downto 0);
  signal cnt_11_reg : std_logic_vector(31 downto 0);
  signal cnt_11_eval : std_logic_vector(31 downto 0);
  signal y_11_next : std_logic_vector(31 downto 0);
  signal y_11_reg : std_logic_vector(31 downto 0);
  signal y_11_eval : std_logic_vector(31 downto 0);
  signal x_21_next : std_logic_vector(31 downto 0);
  signal x_21_reg : std_logic_vector(31 downto 0);
  signal x_21_eval : std_logic_vector(31 downto 0);
  signal on_next : std_logic_vector(31 downto 0);
  signal on_reg : std_logic_vector(31 downto 0);
  signal on_eval : std_logic_vector(31 downto 0);
  signal cnt_next : std_logic_vector(31 downto 0);
  signal cnt_reg : std_logic_vector(31 downto 0);
  signal cnt_eval : std_logic_vector(31 downto 0);
  signal on_0_51_next : std_logic_vector(31 downto 0);
  signal on_0_51_reg : std_logic_vector(31 downto 0);
  signal on_0_51_eval : std_logic_vector(31 downto 0);
  signal x_next : std_logic_vector(31 downto 0);
  signal x_reg : std_logic_vector(31 downto 0);
  signal x_eval : std_logic_vector(31 downto 0);
  signal y_next : std_logic_vector(31 downto 0);
  signal y_reg : std_logic_vector(31 downto 0);
  signal y_eval : std_logic_vector(31 downto 0);
  signal on_0_31_next : std_logic_vector(31 downto 0);
  signal on_0_31_reg : std_logic_vector(31 downto 0);
  signal on_0_31_eval : std_logic_vector(31 downto 0);
  signal y_91_next : std_logic_vector(31 downto 0);
  signal y_91_reg : std_logic_vector(31 downto 0);
  signal y_91_eval : std_logic_vector(31 downto 0);
  signal out1_next : std_logic_vector(31 downto 0);
  signal out1_reg : std_logic_vector(31 downto 0);
  signal out1_eval : std_logic_vector(31 downto 0);
  signal checkpixel_8_start : std_logic;
  signal checkpixel_8_done  : std_logic;
  signal checkpixel_8_ready : std_logic;
  constant CNST_0 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000000000000000";
  constant CNST_1 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000000000000001";
  constant CNST_40 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000000000101000";
  constant CNST_50 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000000000110010";
  constant CNST_950 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000001110110110";
  constant CNST_999 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000001111100111";
  constant CNST_m2100 : std_logic_vector(63 downto 0) := "1111111111111111111111111111111111111111111111111111011111001100";
  constant CNST_m949 : std_logic_vector(63 downto 0) := "1111111111111111111111111111111111111111111111111111110001001011";
begin
  -- current state logic
  process (clk, reset)
  begin
    if (reset = '1') then
      current_state <= S_ENTRY;
      cnt_41_reg <= (others => '0');
      x_71_reg <= (others => '0');
      on_31_reg <= (others => '0');
      cnt_11_reg <= (others => '0');
      y_11_reg <= (others => '0');
      x_21_reg <= (others => '0');
      on_reg <= (others => '0');
      cnt_reg <= (others => '0');
      on_0_51_reg <= (others => '0');
      x_reg <= (others => '0');
      y_reg <= (others => '0');
      on_0_31_reg <= (others => '0');
      y_91_reg <= (others => '0');
      out1_reg <= (others => '0');
    elsif (clk = '1' and clk'EVENT) then
      current_state <= next_state;
      cnt_41_reg <= cnt_41_next;
      x_71_reg <= x_71_next;
      on_31_reg <= on_31_next;
      cnt_11_reg <= cnt_11_next;
      y_11_reg <= y_11_next;
      x_21_reg <= x_21_next;
      on_reg <= on_next;
      cnt_reg <= cnt_next;
      on_0_51_reg <= on_0_51_next;
      x_reg <= x_next;
      y_reg <= y_next;
      on_0_31_reg <= on_0_31_next;
      y_91_reg <= y_91_next;
      out1_reg <= out1_next;
    end if;
  end process;

  -- next state and output logic
  process (current_state, start,
    out1_reg,
    checkpixel_8_start, checkpixel_8_ready, checkpixel_8_done,
    cnt_41_reg, cnt_41_next,
    x_71_reg, x_71_next,
    on_31_reg, on_31_next,
    cnt_11_reg, cnt_11_next,
    y_11_reg, y_11_next,
    x_21_reg, x_21_next,
    on_reg, on_next,
    cnt_reg, cnt_next,
    on_0_51_reg, on_0_51_next,
    x_reg, x_next,
    y_reg, y_next,
    on_0_31_reg, on_0_31_next,
    y_91_reg, y_91_next
  )
  begin
    done <= '0';
    ready <= '0';
    checkpixel_8_start <= '0';
    cnt_41_next <= cnt_41_reg;
    x_71_next <= x_71_reg;
    on_31_next <= on_31_reg;
    cnt_11_next <= cnt_11_reg;
    y_11_next <= y_11_reg;
    x_21_next <= x_21_reg;
    on_next <= on_reg;
    cnt_next <= cnt_reg;
    on_0_51_next <= on_0_51_reg;
    x_next <= x_reg;
    y_next <= y_reg;
    on_0_31_next <= on_0_31_reg;
    y_91_next <= y_91_reg;
    out1_next <= out1_reg;
    case current_state is
      when S_ENTRY =>
        ready <= '1';
        if (start = '1') then
          next_state <= S_001_001;
        else
          next_state <= S_ENTRY;
        end if;
      when S_001_001 =>
        cnt_11_next <= CNST_0(31 downto 0);
        y_11_next <= CNST_950(31 downto 0);
        y_next <= y_11_next (31 downto 0);
        cnt_next <= cnt_11_next (31 downto 0);
        next_state <= S_010_001;
      when S_002_001 =>
        x_21_next <= CNST_m2100(31 downto 0);
        x_next <= x_21_next (31 downto 0);
        next_state <= S_008_001;
      when S_003_001 =>
        if ((checkpixel_8_ready = '1' and checkpixel_8_start = '0')) then
          on_31_next <= on_31_eval;
          next_state <= S_003_002;
        else
          next_state <= S_003_001;
        end if;
      when S_003_002 =>
        on_next <= on_31_reg(31 downto 0);
        on_0_31_next <= on_31_reg(31 downto 0);
        if (signed(on_0_31_next ) = signed(CNST_1(31 downto 0))) then
          next_state <= S_004_001;
        else
          next_state <= S_005_001;
        end if;
      when S_004_001 =>
        cnt_41_next <= std_logic_vector(signed(cnt_reg) + signed(CNST_1(31 downto 0)));
        cnt_next <= cnt_41_next (31 downto 0);
        next_state <= S_005_001; --
      when S_005_001 =>        --
        on_0_51_next <= on_reg(31 downto 0);
        if (signed(on_0_51_next ) = signed(CNST_0(31 downto 0))) then
          next_state <= S_006_001;
        else
          next_state <= S_007_001;
        end if;
      when S_006_001 =>
        next_state <= S_007_001; --
      when S_007_001 =>        --
        x_71_next <= std_logic_vector(signed(x_reg) + signed(CNST_40(31 downto 0)));
        x_next <= x_71_next (31 downto 0);
        next_state <= S_008_001; --
      when S_008_001 =>        --
        if (signed(x_reg) <= signed(CNST_999(31 downto 0))) then
          checkpixel_8_start <= '1';
          next_state <= S_003_001;
        else
          next_state <= S_009_001;
        end if;
      when S_009_001 =>
        y_91_next <= std_logic_vector(signed(y_reg) - signed(CNST_50(31 downto 0)));
        y_next <= y_91_next (31 downto 0);
        next_state <= S_010_001; --
      when S_010_001 =>        --
        if (signed(y_reg) >= signed(CNST_m949(31 downto 0))) then
          next_state <= S_002_001;
        else
          next_state <= S_011_001;
        end if;
      when S_011_001 =>
        out1_next <= cnt_reg(31 downto 0);
        next_state <= S_012_001; --
      when S_012_001 =>        --
        next_state <= S_EXIT; --
      when S_EXIT =>        --
        done <= '1';
        next_state <= S_ENTRY;
      when others =>
        next_state <= S_ENTRY;
    end case;
  end process;

  out1 <= out1_reg;

  checkpixel_8 : entity WORK.checkpixel(fsmd)
    port map (
      clk,
      reset,
      checkpixel_8_start,
      x_reg,
      y_reg,
      on_31_eval,
      checkpixel_8_done,
      checkpixel_8_ready
    );

end fsmd;
