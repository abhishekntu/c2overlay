-- File automatically generated by "cdfg2hdl".
-- Filename: gmp_fibo.vhd
-- Date: 12 October 2013 02:34:33 PM
-- Author: Nikolaos Kavvadias (C) 2009, 2010, 2011, 2012, 2013

library IEEE;
use WORK.operpack.all;
use WORK.gmp_fibo_cdt_pkg.all;
use STD.textio.all;
use WORK.std_logic_textio.all;
use WORK.mpint.all;
use WORK.std_logic_1164_tinyadditions.all;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;


entity gmp_fibo is
  port (
    clk : in std_logic;
    reset : in std_logic;
    start : in std_logic;
    n : in std_logic_vector(31 downto 0);
    D_2845 : out std_logic_vector(31 downto 0);
    done : out std_logic;
    ready : out std_logic
  );
end gmp_fibo;

architecture fsmd of gmp_fibo is
  type state_type is (S_ENTRY, S_EXIT, S_001_001, S_001_002, S_001_003, S_001_004, S_001_005, S_001_006, S_001_007, S_001_008, S_001_009, S_001_010, S_001_011, S_001_012, S_001_013, S_002_001, S_002_002, S_002_003, S_002_004, S_002_005, S_002_006, S_002_007, S_002_008, S_002_009, S_003_001, S_003_002, S_004_001, S_005_001);
  signal current_state, next_state: state_type;
  signal k_21_next : std_logic_vector(31 downto 0);
  signal k_21_reg : std_logic_vector(31 downto 0);
  signal k_21_eval : std_logic_vector(31 downto 0);
  signal t_11_next : std_logic_vector(31 downto 0);
  signal t_11_reg : std_logic_vector(31 downto 0);
  signal t_11_eval : std_logic_vector(31 downto 0);
  signal u_11_next : std_logic_vector(31 downto 0);
  signal u_11_reg : std_logic_vector(31 downto 0);
  signal u_11_eval : std_logic_vector(31 downto 0);
  signal k_11_next : std_logic_vector(31 downto 0);
  signal k_11_reg : std_logic_vector(31 downto 0);
  signal k_11_eval : std_logic_vector(31 downto 0);
  signal f1_next : mp_int;
  signal f1_reg : mp_int;
  signal f1_eval : mp_int;
  signal k_next : std_logic_vector(31 downto 0);
  signal k_reg : std_logic_vector(31 downto 0);
  signal k_eval : std_logic_vector(31 downto 0);
  signal f0_next : mp_int;
  signal f0_reg : mp_int;
  signal f0_eval : mp_int;
  signal f_21_next : mp_int;
  signal f_21_reg : mp_int;
  signal f_21_eval : mp_int;
  signal f0_11_next : mp_int;
  signal f0_11_reg : mp_int;
  signal f0_11_eval : mp_int;
  signal f1_11_next : mp_int;
  signal f1_11_reg : mp_int;
  signal f1_11_eval : mp_int;
  signal f0_21_next : mp_int;
  signal f0_21_reg : mp_int;
  signal f0_21_eval : mp_int;
  signal f1_21_next : mp_int;
  signal f1_21_reg : mp_int;
  signal f1_21_eval : mp_int;
  signal f0_12_next : mp_int;
  signal f0_12_reg : mp_int;
  signal f0_12_eval : mp_int;
  signal f1_12_next : mp_int;
  signal f1_12_reg : mp_int;
  signal f1_12_eval : mp_int;
  signal D_2845_next : std_logic_vector(31 downto 0);
  signal D_2845_reg : std_logic_vector(31 downto 0);
  signal D_2845_eval : std_logic_vector(31 downto 0);
  constant CNST_0 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000000000000000";
  constant CNST_1 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000000000000001";
  constant CNST_2 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000000000000010";
  file infile  : text open READ_MODE is "STD_INPUT";
  file outfile : text open WRITE_MODE is "STD_OUTPUT";
begin
  -- current state logic
  process (clk, reset)
  begin
    if (reset = '1') then
      current_state <= S_ENTRY;
      k_21_reg <= (others => '0');
      t_11_reg <= (others => '0');
      u_11_reg <= (others => '0');
      k_11_reg <= (others => '0');
      f1_reg.data <= (others => 0);
      k_reg <= (others => '0');
      f0_reg.data <= (others => 0);
      f_21_reg.data <= (others => 0);
      f0_11_reg.data <= (others => 0);
      f1_11_reg.data <= (others => 0);
      f0_21_reg.data <= (others => 0);
      f1_21_reg.data <= (others => 0);
      f0_12_reg.data <= (others => 0);
      f1_12_reg.data <= (others => 0);
      D_2845_reg <= (others => '0');
    elsif (clk = '1' and clk'EVENT) then
      current_state <= next_state;
      k_21_reg <= k_21_next;
      t_11_reg <= t_11_next;
      u_11_reg <= u_11_next;
      k_11_reg <= k_11_next;
      f1_reg <= f1_next;
      k_reg <= k_next;
      f0_reg <= f0_next;
      f_21_reg <= f_21_next;
      f0_11_reg <= f0_11_next;
      f1_11_reg <= f1_11_next;
      f0_21_reg <= f0_21_next;
      f1_21_reg <= f1_21_next;
      f0_12_reg <= f0_12_next;
      f1_12_reg <= f1_12_next;
      D_2845_reg <= D_2845_next;
    end if;
  end process;

  -- next state and output logic
  process (current_state, start,
    n,
    D_2845_reg,
    k_21_reg, k_21_next,
    t_11_reg, t_11_next,
    u_11_reg, u_11_next,
    k_11_reg, k_11_next,
    f1_reg, f1_next,
    k_reg, k_next,
    f0_reg, f0_next,
    f_21_reg, f_21_next,
    f0_11_reg, f0_11_next,
    f1_11_reg, f1_11_next,
    f0_21_reg, f0_21_next,
    f1_21_reg, f1_21_next,
    f0_12_reg, f0_12_next,
    f1_12_reg, f1_12_next
  )
    variable linebuf : LINE;
    variable c : CHARACTER;
  begin
    done <= '0';
    ready <= '0';
    k_21_next <= k_21_reg;
    t_11_next <= t_11_reg;
    u_11_next <= u_11_reg;
    k_11_next <= k_11_reg;
    f1_next <= f1_reg;
    k_next <= k_reg;
    f0_next <= f0_reg;
    f_21_next <= f_21_reg;
    f0_11_next <= f0_11_reg;
    f1_11_next <= f1_11_reg;
    f0_21_next <= f0_21_reg;
    f1_21_next <= f1_21_reg;
    f0_12_next <= f0_12_reg;
    f1_12_next <= f1_12_reg;
    D_2845_next <= D_2845_reg;
    case current_state is
      when S_ENTRY =>
        ready <= '1';
        if (start = '1') then
          next_state <= S_001_001;
        else
          next_state <= S_ENTRY;
        end if;
      when S_001_001 =>
        t_11_next <= CNST_0(31 downto 0);
        next_state <= S_001_002;
      when S_001_002 =>
        u_11_next <= CNST_1(31 downto 0);
        next_state <= S_001_003;
      when S_001_003 =>
        next_state <= S_001_004;
      when S_001_004 =>
        next_state <= S_001_005;
      when S_001_005 =>
        f0_12_next <= mpz_set_ui(t_11_reg);
        next_state <= S_001_006;
      when S_001_006 =>
        mpz_printh(f0_12_reg);
        next_state <= S_001_007;
      when S_001_007 =>
        f1_12_next <= mpz_set_ui(u_11_reg);
        next_state <= S_001_008;
      when S_001_008 =>
        mpz_printh(f1_12_reg);
        next_state <= S_001_009;
      when S_001_009 =>
        k_11_next <= CNST_2(31 downto 0);
        next_state <= S_001_010;
      when S_001_010 =>
        f0_next <= f0_12_reg;
        next_state <= S_001_011;
      when S_001_011 =>
        f1_next <= f1_12_reg;
        next_state <= S_001_012;
      when S_001_012 =>
        k_next <= k_11_reg(31 downto 0);
        next_state <= S_001_013;
      when S_001_013 =>
        next_state <= S_002_001;
      when S_002_001 =>
        k_21_next <= std_logic_vector(unsigned(k_reg) + unsigned(CNST_1(31 downto 0)));
        next_state <= S_002_002;
      when S_002_002 =>
        f_21_next <= mpz_add(f1_reg, f0_reg);
        next_state <= S_002_003;
      when S_002_003 =>
        f0_21_next <= mpz_set(f1_reg);
        next_state <= S_002_004;
      when S_002_004 =>
        f1_21_next <= mpz_set(f_21_reg);
        next_state <= S_002_005;
      when S_002_005 =>
        mpz_printh(f_21_reg);
        next_state <= S_002_006;
      when S_002_006 =>
        f0_next <= f0_21_reg;
        next_state <= S_002_007;
      when S_002_007 =>
        f1_next <= f1_21_reg;
        next_state <= S_002_008;
      when S_002_008 =>
        k_next <= k_21_reg(31 downto 0);
        next_state <= S_002_009;
      when S_002_009 =>
        if (k_21_reg <= n(31 downto 0)) then
          next_state <= S_002_001;
        else
          next_state <= S_003_001;
        end if;
      when S_003_001 =>
        D_2845_next <= CNST_0(31 downto 0);
        next_state <= S_003_002;
      when S_003_002 =>
        next_state <= S_005_001;
      when S_004_001 =>
        next_state <= S_005_001;
      when S_005_001 =>
        next_state <= S_EXIT;
      when S_EXIT =>
        done <= '1';
        next_state <= S_ENTRY;
      when others =>
        next_state <= S_ENTRY;
    end case;
  end process;

  D_2845 <= D_2845_reg;

end fsmd;
