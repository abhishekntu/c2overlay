-- File automatically generated by "cdfg2hdl".
-- Filename: c2vwalsh.vhd
-- Date: 12 October 2013 02:31:44 PM
-- Author: Nikolaos Kavvadias (C) 2009, 2010, 2011, 2012, 2013

library IEEE;
use WORK.operpack.all;
use WORK.c2vwalsh_cdt_pkg.all;
use WORK.std_logic_1164_tinyadditions.all;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;


entity c2vwalsh is
  port (
    clk : in std_logic;
    reset : in std_logic;
    start : in std_logic;
    log2N : in std_logic_vector(31 downto 0);
    y : out std_logic_vector(31 downto 0);
    done : out std_logic;
    ready : out std_logic
  );
end c2vwalsh;

architecture fsmd of c2vwalsh is
  type state_type is (S_ENTRY, S_EXIT, S_001_001, S_001_002, S_001_003, S_001_004, S_002_001, S_002_002, S_002_003, S_002_004, S_003_001, S_004_001, S_004_002, S_004_003, S_005_001, S_005_002, S_005_003, S_006_001, S_006_002, S_006_003, S_007_001, S_007_002, S_007_003, S_007_004, S_007_005, S_007_006, S_008_001, S_009_001, S_009_002, S_009_003, S_009_004, S_010_001, S_011_001, S_011_002, S_011_003, S_012_001, S_013_001, S_013_002, S_014_001);
  signal current_state, next_state: state_type;
  signal h_Input : h_Input_type := (
    0 => "00000000000000000000000000000001",
    1 => "00000000000000000000000000000010",
    2 => "00000000000000000000000000000011",
    3 => "00000000000000000000000000000100",
    4 => "00000000000000000000000000000101",
    5 => "00000000000000000000000000000110",
    6 => "00000000000000000000000000000111",
    7 => "00000000000000000000000000001000",
    8 => "00000000000000000000000000001001",
    9 => "00000000000000000000000000001010",
    10 => "00000000000000000000000000001011",
    11 => "00000000000000000000000000001100",
    12 => "00000000000000000000000000001101",
    13 => "00000000000000000000000000001110",
    14 => "00000000000000000000000000001111",
    15 => "00000000000000000000000000010000",
    others => (others => '0'));
  signal h_Output : h_Output_type := (
    others => (others => '0'));
  signal i0_71_next : std_logic_vector(31 downto 0);
  signal i0_71_reg : std_logic_vector(31 downto 0);
  signal i0_71_eval : std_logic_vector(31 downto 0);
  signal D_1390_71_next : std_logic_vector(31 downto 0);
  signal D_1390_71_reg : std_logic_vector(31 downto 0);
  signal D_1390_71_eval : std_logic_vector(31 downto 0);
  signal i1_71_next : std_logic_vector(31 downto 0);
  signal i1_71_reg : std_logic_vector(31 downto 0);
  signal i1_71_eval : std_logic_vector(31 downto 0);
  signal D_1392_71_next : std_logic_vector(31 downto 0);
  signal D_1392_71_reg : std_logic_vector(31 downto 0);
  signal D_1392_71_eval : std_logic_vector(31 downto 0);
  signal j_71_next : std_logic_vector(31 downto 0);
  signal j_71_reg : std_logic_vector(31 downto 0);
  signal j_71_eval : std_logic_vector(31 downto 0);
  signal base_91_next : std_logic_vector(31 downto 0);
  signal base_91_reg : std_logic_vector(31 downto 0);
  signal base_91_eval : std_logic_vector(31 downto 0);
  signal pos_21_next : std_logic_vector(31 downto 0);
  signal pos_21_reg : std_logic_vector(31 downto 0);
  signal pos_21_eval : std_logic_vector(31 downto 0);
  signal stride_41_next : std_logic_vector(31 downto 0);
  signal stride_41_reg : std_logic_vector(31 downto 0);
  signal stride_41_eval : std_logic_vector(31 downto 0);
  signal k_11_next : std_logic_vector(31 downto 0);
  signal k_11_reg : std_logic_vector(31 downto 0);
  signal k_11_eval : std_logic_vector(31 downto 0);
  signal base_51_next : std_logic_vector(31 downto 0);
  signal base_51_reg : std_logic_vector(31 downto 0);
  signal base_51_eval : std_logic_vector(31 downto 0);
  signal j_61_next : std_logic_vector(31 downto 0);
  signal j_61_reg : std_logic_vector(31 downto 0);
  signal j_61_eval : std_logic_vector(31 downto 0);
  signal pos_11_next : std_logic_vector(31 downto 0);
  signal pos_11_reg : std_logic_vector(31 downto 0);
  signal pos_11_eval : std_logic_vector(31 downto 0);
  signal T1_71_next : std_logic_vector(31 downto 0);
  signal T1_71_reg : std_logic_vector(31 downto 0);
  signal T1_71_eval : std_logic_vector(31 downto 0);
  signal T2_71_next : std_logic_vector(31 downto 0);
  signal T2_71_reg : std_logic_vector(31 downto 0);
  signal T2_71_eval : std_logic_vector(31 downto 0);
  signal D_1389_21_next : std_logic_vector(31 downto 0);
  signal D_1389_21_reg : std_logic_vector(31 downto 0);
  signal D_1389_21_eval : std_logic_vector(31 downto 0);
  signal pos_next : std_logic_vector(31 downto 0);
  signal pos_reg : std_logic_vector(31 downto 0);
  signal pos_eval : std_logic_vector(31 downto 0);
  signal stride_next : std_logic_vector(31 downto 0);
  signal stride_reg : std_logic_vector(31 downto 0);
  signal stride_eval : std_logic_vector(31 downto 0);
  signal base_next : std_logic_vector(31 downto 0);
  signal base_reg : std_logic_vector(31 downto 0);
  signal base_eval : std_logic_vector(31 downto 0);
  signal j_next : std_logic_vector(31 downto 0);
  signal j_reg : std_logic_vector(31 downto 0);
  signal j_eval : std_logic_vector(31 downto 0);
  signal N_next : std_logic_vector(31 downto 0);
  signal N_reg : std_logic_vector(31 downto 0);
  signal N_eval : std_logic_vector(31 downto 0);
  signal D_1393_91_next : std_logic_vector(31 downto 0);
  signal D_1393_91_reg : std_logic_vector(31 downto 0);
  signal D_1393_91_eval : std_logic_vector(31 downto 0);
  signal N_11_next : std_logic_vector(31 downto 0);
  signal N_11_reg : std_logic_vector(31 downto 0);
  signal N_11_eval : std_logic_vector(31 downto 0);
  signal stride_111_next : std_logic_vector(31 downto 0);
  signal stride_111_reg : std_logic_vector(31 downto 0);
  signal stride_111_eval : std_logic_vector(31 downto 0);
  signal D_1391_71_next : std_logic_vector(31 downto 0);
  signal D_1391_71_reg : std_logic_vector(31 downto 0);
  signal D_1391_71_eval : std_logic_vector(31 downto 0);
  signal log2N_0_11_next : std_logic_vector(31 downto 0);
  signal log2N_0_11_reg : std_logic_vector(31 downto 0);
  signal log2N_0_11_eval : std_logic_vector(31 downto 0);
  signal y_next : std_logic_vector(31 downto 0);
  signal y_reg : std_logic_vector(31 downto 0);
  signal y_eval : std_logic_vector(31 downto 0);
  constant CNST_0 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000000000000000";
  constant CNST_1 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000000000000001";
  constant CNST_2 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000000000000010";
begin
  -- current state logic
  process (clk, reset)
  begin
    if (reset = '1') then
      current_state <= S_ENTRY;
      i0_71_reg <= (others => '0');
      D_1390_71_reg <= (others => '0');
      i1_71_reg <= (others => '0');
      D_1392_71_reg <= (others => '0');
      j_71_reg <= (others => '0');
      base_91_reg <= (others => '0');
      pos_21_reg <= (others => '0');
      stride_41_reg <= (others => '0');
      k_11_reg <= (others => '0');
      base_51_reg <= (others => '0');
      j_61_reg <= (others => '0');
      pos_11_reg <= (others => '0');
      T1_71_reg <= (others => '0');
      T2_71_reg <= (others => '0');
      D_1389_21_reg <= (others => '0');
      pos_reg <= (others => '0');
      stride_reg <= (others => '0');
      base_reg <= (others => '0');
      j_reg <= (others => '0');
      N_reg <= (others => '0');
      D_1393_91_reg <= (others => '0');
      N_11_reg <= (others => '0');
      stride_111_reg <= (others => '0');
      D_1391_71_reg <= (others => '0');
      log2N_0_11_reg <= (others => '0');
      y_reg <= (others => '0');
    elsif (clk = '1' and clk'EVENT) then
      current_state <= next_state;
      i0_71_reg <= i0_71_next;
      D_1390_71_reg <= D_1390_71_next;
      i1_71_reg <= i1_71_next;
      D_1392_71_reg <= D_1392_71_next;
      j_71_reg <= j_71_next;
      base_91_reg <= base_91_next;
      pos_21_reg <= pos_21_next;
      stride_41_reg <= stride_41_next;
      k_11_reg <= k_11_next;
      base_51_reg <= base_51_next;
      j_61_reg <= j_61_next;
      pos_11_reg <= pos_11_next;
      T1_71_reg <= T1_71_next;
      T2_71_reg <= T2_71_next;
      D_1389_21_reg <= D_1389_21_next;
      pos_reg <= pos_next;
      stride_reg <= stride_next;
      base_reg <= base_next;
      j_reg <= j_next;
      N_reg <= N_next;
      D_1393_91_reg <= D_1393_91_next;
      N_11_reg <= N_11_next;
      stride_111_reg <= stride_111_next;
      D_1391_71_reg <= D_1391_71_next;
      log2N_0_11_reg <= log2N_0_11_next;
      y_reg <= y_next;
    end if;
  end process;

  -- next state and output logic
  process (current_state, start,
    log2N,
    y_reg,
    i0_71_reg, i0_71_next,
    D_1390_71_reg, D_1390_71_next,
    i1_71_reg, i1_71_next,
    D_1392_71_reg, D_1392_71_next,
    j_71_reg, j_71_next,
    base_91_reg, base_91_next,
    pos_21_reg, pos_21_next,
    stride_41_reg, stride_41_next,
    k_11_reg, k_11_next,
    base_51_reg, base_51_next,
    j_61_reg, j_61_next,
    pos_11_reg, pos_11_next,
    T1_71_reg, T1_71_next,
    T2_71_reg, T2_71_next,
    D_1389_21_reg, D_1389_21_next,
    pos_reg, pos_next,
    stride_reg, stride_next,
    base_reg, base_next,
    j_reg, j_next,
    N_reg, N_next,
    D_1393_91_reg, D_1393_91_next,
    N_11_reg, N_11_next,
    stride_111_reg, stride_111_next,
    D_1391_71_reg, D_1391_71_next,
    log2N_0_11_reg, log2N_0_11_next
  )
  begin
    done <= '0';
    ready <= '0';
    i0_71_next <= i0_71_reg;
    D_1390_71_next <= D_1390_71_reg;
    i1_71_next <= i1_71_reg;
    D_1392_71_next <= D_1392_71_reg;
    j_71_next <= j_71_reg;
    base_91_next <= base_91_reg;
    pos_21_next <= pos_21_reg;
    stride_41_next <= stride_41_reg;
    k_11_next <= k_11_reg;
    base_51_next <= base_51_reg;
    j_61_next <= j_61_reg;
    pos_11_next <= pos_11_reg;
    T1_71_next <= T1_71_reg;
    T2_71_next <= T2_71_reg;
    D_1389_21_next <= D_1389_21_reg;
    pos_next <= pos_reg;
    stride_next <= stride_reg;
    base_next <= base_reg;
    j_next <= j_reg;
    N_next <= N_reg;
    D_1393_91_next <= D_1393_91_reg;
    N_11_next <= N_11_reg;
    stride_111_next <= stride_111_reg;
    D_1391_71_next <= D_1391_71_reg;
    log2N_0_11_next <= log2N_0_11_reg;
    y_next <= y_reg;
    case current_state is
      when S_ENTRY =>
        ready <= '1';
        if (start = '1') then
          next_state <= S_001_001;
        else
          next_state <= S_ENTRY;
        end if;
      when S_001_001 =>
        k_11_next <= CNST_1(31 downto 0);
        pos_11_next <= CNST_0(31 downto 0);
        log2N_0_11_next(31 downto 0) <= log2N;
        next_state <= S_001_002;
      when S_001_002 =>
        pos_next <= pos_11_reg(31 downto 0);
        N_11_next <= shlv5(k_11_reg, log2N_0_11_reg);
        next_state <= S_001_003;
      when S_001_003 =>
        N_next <= N_11_reg(31 downto 0);
        next_state <= S_001_004;
      when S_001_004 =>
        next_state <= S_003_001;
      when S_002_001 =>
        pos_21_next <= std_logic_vector(unsigned(pos_reg) + unsigned(CNST_1(31 downto 0)));
        D_1389_21_next <= h_Input(to_integer(unsigned(pos_reg(3 downto 0))));
        next_state <= S_002_002;
      when S_002_002 =>
        h_Output(to_integer(unsigned(pos_reg(3 downto 0)))) <= D_1389_21_reg(31 downto 0);
        next_state <= S_002_003;
      when S_002_003 =>
        pos_next <= pos_21_reg(31 downto 0);
        next_state <= S_002_004;
      when S_002_004 =>
        next_state <= S_003_001;
      when S_003_001 =>
        if (pos_reg < N_reg(31 downto 0)) then
          next_state <= S_002_001;
        else
          next_state <= S_004_001;
        end if;
      when S_004_001 =>
        divq(N_reg, CNST_2(31 downto 0), '0', stride_41_next);
        next_state <= S_004_002;
      when S_004_002 =>
        stride_next <= stride_41_reg(31 downto 0);
        next_state <= S_004_003;
      when S_004_003 =>
        next_state <= S_012_001;
      when S_005_001 =>
        base_51_next <= CNST_0(31 downto 0);
        next_state <= S_005_002;
      when S_005_002 =>
        base_next <= base_51_reg(31 downto 0);
        next_state <= S_005_003;
      when S_005_003 =>
        next_state <= S_010_001;
      when S_006_001 =>
        j_61_next <= CNST_0(31 downto 0);
        next_state <= S_006_002;
      when S_006_002 =>
        j_next <= j_61_reg(31 downto 0);
        next_state <= S_006_003;
      when S_006_003 =>
        next_state <= S_008_001;
      when S_007_001 =>
        i0_71_next <= std_logic_vector(unsigned(base_reg) + unsigned(j_reg(31 downto 0)));
        D_1390_71_next <= std_logic_vector(unsigned(base_reg) + unsigned(j_reg(31 downto 0)));
        j_71_next <= std_logic_vector(unsigned(j_reg) + unsigned(CNST_1(31 downto 0)));
        next_state <= S_007_002;
      when S_007_002 =>
        i1_71_next <= std_logic_vector(unsigned(D_1390_71_reg) + unsigned(stride_reg(31 downto 0)));
        T1_71_next <= h_Output(to_integer(unsigned(i0_71_reg(3 downto 0))));
        j_next <= j_71_reg(31 downto 0);
        next_state <= S_007_003;
      when S_007_003 =>
        T2_71_next <= h_Output(to_integer(unsigned(i1_71_reg(3 downto 0))));
        next_state <= S_007_004;
      when S_007_004 =>
        D_1392_71_next <= std_logic_vector(unsigned(T1_71_reg) + unsigned(T2_71_reg(31 downto 0)));
        D_1391_71_next <= std_logic_vector(unsigned(T1_71_reg) - unsigned(T2_71_reg(31 downto 0)));
        next_state <= S_007_005;
      when S_007_005 =>
        h_Output(to_integer(unsigned(i1_71_reg(3 downto 0)))) <= D_1391_71_reg(31 downto 0);
        h_Output(to_integer(unsigned(i0_71_reg(3 downto 0)))) <= D_1392_71_reg(31 downto 0);
        next_state <= S_007_006;
      when S_007_006 =>
        next_state <= S_008_001;
      when S_008_001 =>
        if (j_reg < stride_reg(31 downto 0)) then
          next_state <= S_007_001;
        else
          next_state <= S_009_001;
        end if;
      when S_009_001 =>
        D_1393_91_next <= mul(stride_reg, CNST_2(31 downto 0), '0', 32);
        next_state <= S_009_002;
      when S_009_002 =>
        base_91_next <= std_logic_vector(unsigned(D_1393_91_reg) + unsigned(base_reg(31 downto 0)));
        next_state <= S_009_003;
      when S_009_003 =>
        base_next <= base_91_reg(31 downto 0);
        next_state <= S_009_004;
      when S_009_004 =>
        next_state <= S_010_001;
      when S_010_001 =>
        if (base_reg < N_reg(31 downto 0)) then
          next_state <= S_006_001;
        else
          next_state <= S_011_001;
        end if;
      when S_011_001 =>
        stride_111_next <= "0" & stride_reg(31 downto 1);
        next_state <= S_011_002;
      when S_011_002 =>
        stride_next <= stride_111_reg(31 downto 0);
        next_state <= S_011_003;
      when S_011_003 =>
        next_state <= S_012_001;
      when S_012_001 =>
        if (stride_reg /= CNST_0(31 downto 0)) then
          next_state <= S_005_001;
        else
          next_state <= S_013_001;
        end if;
      when S_013_001 =>
        y_next <= CNST_1(31 downto 0);
        next_state <= S_013_002;
      when S_013_002 =>
        next_state <= S_014_001;
      when S_014_001 =>
        next_state <= S_EXIT;
      when S_EXIT =>
        done <= '1';
        next_state <= S_ENTRY;
      when others =>
        next_state <= S_ENTRY;
    end case;
  end process;

  y <= y_reg;

end fsmd;
