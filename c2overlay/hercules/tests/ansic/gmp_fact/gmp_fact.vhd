-- File automatically generated by "cdfg2hdl".
-- Filename: gmp_fact.vhd
-- Date: 16 October 2013 11:51:20 AM
-- Author: Nikolaos Kavvadias (C) 2009, 2010, 2011, 2012, 2013

library IEEE;
use WORK.operpack.all;
use WORK.gmp_fact_cdt_pkg.all;
use STD.textio.all;
use WORK.std_logic_textio.all;
use WORK.mpint.all;
use WORK.std_logic_1164_tinyadditions.all;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;


entity gmp_fact is
  port (
    clk : in std_logic;
    reset : in std_logic;
    start : in std_logic;
    n : in std_logic_vector(31 downto 0);
    D_2846 : out std_logic_vector(31 downto 0);
    done : out std_logic;
    ready : out std_logic
  );
end gmp_fact;

architecture fsmd of gmp_fact is
  type state_type is (S_ENTRY, S_EXIT, S_001_001, S_001_002, S_001_003, S_001_004, S_001_005, S_001_006, S_001_007, S_001_008, S_002_001, S_002_002, S_002_003, S_002_004, S_002_005, S_002_006, S_002_007, S_003_001, S_003_002, S_004_001, S_004_002, S_005_001, S_006_001);
  signal current_state, next_state: state_type;
  signal i_21_next : std_logic_vector(31 downto 0);
  signal i_21_reg : std_logic_vector(31 downto 0);
  signal i_21_eval : std_logic_vector(31 downto 0);
  signal m_11_next : std_logic_vector(31 downto 0);
  signal m_11_reg : std_logic_vector(31 downto 0);
  signal m_11_eval : std_logic_vector(31 downto 0);
  signal i_11_next : std_logic_vector(31 downto 0);
  signal i_11_reg : std_logic_vector(31 downto 0);
  signal i_11_eval : std_logic_vector(31 downto 0);
  signal prod_next : mp_int;
  signal prod_reg : mp_int;
  signal prod_eval : mp_int;
  signal i_next : std_logic_vector(31 downto 0);
  signal i_reg : std_logic_vector(31 downto 0);
  signal i_eval : std_logic_vector(31 downto 0);
  signal prod_11_next : mp_int;
  signal prod_11_reg : mp_int;
  signal prod_11_eval : mp_int;
  signal prod_21_next : mp_int;
  signal prod_21_reg : mp_int;
  signal prod_21_eval : mp_int;
  signal prod_12_next : mp_int;
  signal prod_12_reg : mp_int;
  signal prod_12_eval : mp_int;
  signal i_2_31_next : std_logic_vector(31 downto 0);
  signal i_2_31_reg : std_logic_vector(31 downto 0);
  signal i_2_31_eval : std_logic_vector(31 downto 0);
  signal m_0_11_next : std_logic_vector(31 downto 0);
  signal m_0_11_reg : std_logic_vector(31 downto 0);
  signal m_0_11_eval : std_logic_vector(31 downto 0);
  signal i_1_21_next : std_logic_vector(31 downto 0);
  signal i_1_21_reg : std_logic_vector(31 downto 0);
  signal i_1_21_eval : std_logic_vector(31 downto 0);
  signal D_2846_next : std_logic_vector(31 downto 0);
  signal D_2846_reg : std_logic_vector(31 downto 0);
  signal D_2846_eval : std_logic_vector(31 downto 0);
  constant CNST_0 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000000000000000";
  constant CNST_1 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000000000000001";
  constant CNST_2 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000000000000010";
  file infile  : text open READ_MODE is "STD_INPUT";
  file outfile : text open WRITE_MODE is "STD_OUTPUT";
begin
  -- current state logic
  process (clk, reset)
  begin
    if (reset = '1') then
      current_state <= S_ENTRY;
      i_21_reg <= (others => '0');
      m_11_reg <= (others => '0');
      i_11_reg <= (others => '0');
      prod_reg.data <= (others => 0);
      i_reg <= (others => '0');
      prod_11_reg.data <= (others => 0);
      prod_21_reg.data <= (others => 0);
      prod_12_reg.data <= (others => 0);
      i_2_31_reg <= (others => '0');
      m_0_11_reg <= (others => '0');
      i_1_21_reg <= (others => '0');
      D_2846_reg <= (others => '0');
    elsif (clk = '1' and clk'EVENT) then
      current_state <= next_state;
      i_21_reg <= i_21_next;
      m_11_reg <= m_11_next;
      i_11_reg <= i_11_next;
      prod_reg <= prod_next;
      i_reg <= i_next;
      prod_11_reg <= prod_11_next;
      prod_21_reg <= prod_21_next;
      prod_12_reg <= prod_12_next;
      i_2_31_reg <= i_2_31_next;
      m_0_11_reg <= m_0_11_next;
      i_1_21_reg <= i_1_21_next;
      D_2846_reg <= D_2846_next;
    end if;
  end process;

  -- next state and output logic
  process (current_state, start,
    n,
    D_2846_reg,
    i_21_reg, i_21_next,
    m_11_reg, m_11_next,
    i_11_reg, i_11_next,
    prod_reg, prod_next,
    i_reg, i_next,
    prod_11_reg, prod_11_next,
    prod_21_reg, prod_21_next,
    prod_12_reg, prod_12_next,
    i_2_31_reg, i_2_31_next,
    m_0_11_reg, m_0_11_next,
    i_1_21_reg, i_1_21_next
  )
    variable linebuf : LINE;
    variable c : CHARACTER;
  begin
    done <= '0';
    ready <= '0';
    i_21_next <= i_21_reg;
    m_11_next <= m_11_reg;
    i_11_next <= i_11_reg;
    prod_next <= prod_reg;
    i_next <= i_reg;
    prod_11_next <= prod_11_reg;
    prod_21_next <= prod_21_reg;
    prod_12_next <= prod_12_reg;
    i_2_31_next <= i_2_31_reg;
    m_0_11_next <= m_0_11_reg;
    i_1_21_next <= i_1_21_reg;
    D_2846_next <= D_2846_reg;
    case current_state is
      when S_ENTRY =>
        ready <= '1';
        if (start = '1') then
          next_state <= S_001_001;
        else
          next_state <= S_ENTRY;
        end if;
      when S_001_001 =>
        m_11_next <= CNST_1(31 downto 0);
        next_state <= S_001_002;
      when S_001_002 =>
        next_state <= S_001_003;
      when S_001_003 =>
        m_0_11_next(31 downto 0) <= m_11_reg;
        next_state <= S_001_004;
      when S_001_004 =>
        prod_12_next <= mpz_set_ui(m_0_11_reg);
        next_state <= S_001_005;
      when S_001_005 =>
        i_11_next <= CNST_2(31 downto 0);
        next_state <= S_001_006;
      when S_001_006 =>
        prod_next <= prod_12_reg;
        next_state <= S_001_007;
      when S_001_007 =>
        i_next <= i_11_reg(31 downto 0);
        next_state <= S_001_008;
      when S_001_008 =>
        next_state <= S_003_001;
      when S_002_001 =>
        i_1_21_next(31 downto 0) <= i_reg;
        next_state <= S_002_002;
      when S_002_002 =>
        prod_21_next <= mpz_mul_ui(prod_reg, i_1_21_reg);
        next_state <= S_002_003;
      when S_002_003 =>
        mpz_printh(prod_21_reg);
        next_state <= S_002_004;
      when S_002_004 =>
        i_21_next <= std_logic_vector(signed(i_reg) + signed(CNST_1(31 downto 0)));
        next_state <= S_002_005;
      when S_002_005 =>
        prod_next <= prod_21_reg;
        next_state <= S_002_006;
      when S_002_006 =>
        i_next <= i_21_reg(31 downto 0);
        next_state <= S_002_007;
      when S_002_007 =>
        next_state <= S_003_001;
      when S_003_001 =>
        i_2_31_next(31 downto 0) <= i_reg;
        next_state <= S_003_002;
      when S_003_002 =>
        if (i_2_31_reg <= n(31 downto 0)) then
          next_state <= S_002_001;
        else
          next_state <= S_004_001;
        end if;
      when S_004_001 =>
        D_2846_next <= CNST_0(31 downto 0);
        next_state <= S_004_002;
      when S_004_002 =>
        next_state <= S_006_001;
      when S_005_001 =>
        next_state <= S_006_001;
      when S_006_001 =>
        next_state <= S_EXIT;
      when S_EXIT =>
        done <= '1';
        next_state <= S_ENTRY;
      when others =>
        next_state <= S_ENTRY;
    end case;
  end process;

  D_2846 <= D_2846_reg;

end fsmd;
