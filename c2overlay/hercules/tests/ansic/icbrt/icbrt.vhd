-- File automatically generated by "cdfg2hdl".
-- Filename: icbrt.vhd
-- Date: 12 October 2013 04:22:54 PM
-- Author: Nikolaos Kavvadias (C) 2009, 2010, 2011, 2012, 2013

library IEEE;
use WORK.operpack.all;
use WORK.icbrt_cdt_pkg.all;
use WORK.std_logic_1164_tinyadditions.all;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;


entity icbrt is
  port (
    clk : in std_logic;
    reset : in std_logic;
    start : in std_logic;
    x : in std_logic_vector(31 downto 0);
    res : out std_logic_vector(31 downto 0);
    done : out std_logic;
    ready : out std_logic
  );
end icbrt;

architecture fsmd of icbrt is
  type state_type is (S_ENTRY, S_EXIT, S_001_001, S_001_002, S_001_003, S_002_001, S_002_002, S_002_003, S_002_004, S_002_005, S_002_006, S_002_007, S_002_008, S_003_001, S_003_002, S_003_003, S_004_001, S_005_001, S_006_001, S_006_002, S_006_003, S_007_001);
  signal current_state, next_state: state_type;
  signal D_1374_21_next : std_logic_vector(31 downto 0);
  signal D_1374_21_reg : std_logic_vector(31 downto 0);
  signal D_1374_21_eval : std_logic_vector(31 downto 0);
  signal y_31_next : std_logic_vector(31 downto 0);
  signal y_31_reg : std_logic_vector(31 downto 0);
  signal y_31_eval : std_logic_vector(31 downto 0);
  signal D_1371_21_next : std_logic_vector(31 downto 0);
  signal D_1371_21_reg : std_logic_vector(31 downto 0);
  signal D_1371_21_eval : std_logic_vector(31 downto 0);
  signal s_11_next : std_logic_vector(31 downto 0);
  signal s_11_reg : std_logic_vector(31 downto 0);
  signal s_11_eval : std_logic_vector(31 downto 0);
  signal y_11_next : std_logic_vector(31 downto 0);
  signal y_11_reg : std_logic_vector(31 downto 0);
  signal y_11_eval : std_logic_vector(31 downto 0);
  signal s_next : std_logic_vector(31 downto 0);
  signal s_reg : std_logic_vector(31 downto 0);
  signal s_eval : std_logic_vector(31 downto 0);
  signal y_next : std_logic_vector(31 downto 0);
  signal y_reg : std_logic_vector(31 downto 0);
  signal y_eval : std_logic_vector(31 downto 0);
  signal b_next : std_logic_vector(31 downto 0);
  signal b_reg : std_logic_vector(31 downto 0);
  signal b_eval : std_logic_vector(31 downto 0);
  signal x0_next : std_logic_vector(31 downto 0);
  signal x0_reg : std_logic_vector(31 downto 0);
  signal x0_eval : std_logic_vector(31 downto 0);
  signal x0_11_next : std_logic_vector(31 downto 0);
  signal x0_11_reg : std_logic_vector(31 downto 0);
  signal x0_11_eval : std_logic_vector(31 downto 0);
  signal D_1373_21_next : std_logic_vector(31 downto 0);
  signal D_1373_21_reg : std_logic_vector(31 downto 0);
  signal D_1373_21_eval : std_logic_vector(31 downto 0);
  signal y_21_next : std_logic_vector(31 downto 0);
  signal y_21_reg : std_logic_vector(31 downto 0);
  signal y_21_eval : std_logic_vector(31 downto 0);
  signal D_1372_21_next : std_logic_vector(31 downto 0);
  signal D_1372_21_reg : std_logic_vector(31 downto 0);
  signal D_1372_21_eval : std_logic_vector(31 downto 0);
  signal b_21_next : std_logic_vector(31 downto 0);
  signal b_21_reg : std_logic_vector(31 downto 0);
  signal b_21_eval : std_logic_vector(31 downto 0);
  signal s_21_next : std_logic_vector(31 downto 0);
  signal s_21_reg : std_logic_vector(31 downto 0);
  signal s_21_eval : std_logic_vector(31 downto 0);
  signal x0_31_next : std_logic_vector(31 downto 0);
  signal x0_31_reg : std_logic_vector(31 downto 0);
  signal x0_31_eval : std_logic_vector(31 downto 0);
  signal y_0_61_next : std_logic_vector(31 downto 0);
  signal y_0_61_reg : std_logic_vector(31 downto 0);
  signal y_0_61_eval : std_logic_vector(31 downto 0);
  signal res_next : std_logic_vector(31 downto 0);
  signal res_reg : std_logic_vector(31 downto 0);
  signal res_eval : std_logic_vector(31 downto 0);
  constant CNST_0 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000000000000000";
  constant CNST_1 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000000000000001";
  constant CNST_2 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000000000000010";
  constant CNST_3 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000000000000011";
  constant CNST_30 : std_logic_vector(63 downto 0) := "0000000000000000000000000000000000000000000000000000000000011110";
begin
  -- current state logic
  process (clk, reset)
  begin
    if (reset = '1') then
      current_state <= S_ENTRY;
      D_1374_21_reg <= (others => '0');
      y_31_reg <= (others => '0');
      D_1371_21_reg <= (others => '0');
      s_11_reg <= (others => '0');
      y_11_reg <= (others => '0');
      s_reg <= (others => '0');
      y_reg <= (others => '0');
      b_reg <= (others => '0');
      x0_reg <= (others => '0');
      x0_11_reg <= (others => '0');
      D_1373_21_reg <= (others => '0');
      y_21_reg <= (others => '0');
      D_1372_21_reg <= (others => '0');
      b_21_reg <= (others => '0');
      s_21_reg <= (others => '0');
      x0_31_reg <= (others => '0');
      y_0_61_reg <= (others => '0');
      res_reg <= (others => '0');
    elsif (clk = '1' and clk'EVENT) then
      current_state <= next_state;
      D_1374_21_reg <= D_1374_21_next;
      y_31_reg <= y_31_next;
      D_1371_21_reg <= D_1371_21_next;
      s_11_reg <= s_11_next;
      y_11_reg <= y_11_next;
      s_reg <= s_next;
      y_reg <= y_next;
      b_reg <= b_next;
      x0_reg <= x0_next;
      x0_11_reg <= x0_11_next;
      D_1373_21_reg <= D_1373_21_next;
      y_21_reg <= y_21_next;
      D_1372_21_reg <= D_1372_21_next;
      b_21_reg <= b_21_next;
      s_21_reg <= s_21_next;
      x0_31_reg <= x0_31_next;
      y_0_61_reg <= y_0_61_next;
      res_reg <= res_next;
    end if;
  end process;

  -- next state and output logic
  process (current_state, start,
    x,
    res_reg,
    D_1374_21_reg, D_1374_21_next,
    y_31_reg, y_31_next,
    D_1371_21_reg, D_1371_21_next,
    s_11_reg, s_11_next,
    y_11_reg, y_11_next,
    s_reg, s_next,
    y_reg, y_next,
    b_reg, b_next,
    x0_reg, x0_next,
    x0_11_reg, x0_11_next,
    D_1373_21_reg, D_1373_21_next,
    y_21_reg, y_21_next,
    D_1372_21_reg, D_1372_21_next,
    b_21_reg, b_21_next,
    s_21_reg, s_21_next,
    x0_31_reg, x0_31_next,
    y_0_61_reg, y_0_61_next
  )
  begin
    done <= '0';
    ready <= '0';
    D_1374_21_next <= D_1374_21_reg;
    y_31_next <= y_31_reg;
    D_1371_21_next <= D_1371_21_reg;
    s_11_next <= s_11_reg;
    y_11_next <= y_11_reg;
    s_next <= s_reg;
    y_next <= y_reg;
    b_next <= b_reg;
    x0_next <= x0_reg;
    x0_11_next <= x0_11_reg;
    D_1373_21_next <= D_1373_21_reg;
    y_21_next <= y_21_reg;
    D_1372_21_next <= D_1372_21_reg;
    b_21_next <= b_21_reg;
    s_21_next <= s_21_reg;
    x0_31_next <= x0_31_reg;
    y_0_61_next <= y_0_61_reg;
    res_next <= res_reg;
    case current_state is
      when S_ENTRY =>
        ready <= '1';
        if (start = '1') then
          next_state <= S_001_001;
        else
          next_state <= S_ENTRY;
        end if;
      when S_001_001 =>
        s_11_next <= CNST_30(31 downto 0);
        y_11_next <= CNST_0(31 downto 0);
        x0_11_next <= x(31 downto 0);
        s_next <= s_11_next (31 downto 0);
        y_next <= y_11_next (31 downto 0);
        x0_next <= x0_11_next (31 downto 0);
        next_state <= S_005_001;
      when S_002_001 =>
        y_21_next <= mul(y_reg, CNST_2(31 downto 0), '0', 32);
        s_21_next <= std_logic_vector(signed(s_reg) - signed(CNST_3(31 downto 0)));
        D_1371_21_next <= std_logic_vector(unsigned(y_21_next ) + unsigned(CNST_1(31 downto 0)));
        y_next <= y_21_next (31 downto 0);
        D_1372_21_next <= mul(D_1371_21_next , y_21_next (31 downto 0), '0', 32);
        D_1373_21_next <= mul(D_1372_21_next , CNST_3(31 downto 0), '0', 32);
        D_1374_21_next <= std_logic_vector(unsigned(D_1373_21_next ) + unsigned(CNST_1(31 downto 0)));
        b_21_next <= shlv5(D_1374_21_next , s_reg);
        s_next <= s_21_next (31 downto 0);
        b_next <= b_21_next (31 downto 0);
        if (x0_reg >= b_21_next (31 downto 0)) then
          next_state <= S_003_001;
        else
          next_state <= S_004_001;
        end if;
      when S_003_001 =>
        y_31_next <= std_logic_vector(unsigned(y_reg) + unsigned(CNST_1(31 downto 0)));
        x0_31_next <= std_logic_vector(unsigned(x0_reg) - unsigned(b_reg(31 downto 0)));
        y_next <= y_31_next (31 downto 0);
        x0_next <= x0_31_next (31 downto 0);
        next_state <= S_004_001; --
      when S_004_001 =>        --
        next_state <= S_005_001; --
      when S_005_001 =>        --
        if (signed(s_reg) >= signed(CNST_0(31 downto 0))) then
          next_state <= S_002_001;
        else
          next_state <= S_006_001;
        end if;
      when S_006_001 =>
        y_0_61_next(31 downto 0) <= y_reg;
        res_next <= y_0_61_next (31 downto 0);
        next_state <= S_007_001; --
      when S_007_001 =>        --
        next_state <= S_EXIT; --
      when S_EXIT =>        --
        done <= '1';
        next_state <= S_ENTRY;
      when others =>
        next_state <= S_ENTRY;
    end case;
  end process;

  res <= res_reg;

end fsmd;
