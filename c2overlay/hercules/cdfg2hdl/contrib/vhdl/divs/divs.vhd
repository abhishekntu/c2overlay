-- File automatically generated by "cdfg2hdl".
-- Filename: divs.vhd
-- Date: 28 September 2011 03:06:04 PM
-- Author: Nikolaos Kavvadias (C) 2009, 2010, 2011
library IEEE;
use WORK.operpack.all;
use WORK.std_logic_1164_tinyadditions.all;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity divs is
  generic (
    W     : integer := 32
  );
  port (
    clk   : in  std_logic;
    reset : in  std_logic;
    start : in  std_logic;
    x     : in  std_logic_vector;
    y     : in  std_logic_vector;
    q     : out std_logic_vector;
    done  : out std_logic;
    ready : out std_logic
  );
end divs;

architecture fsmd of divs is
  type state_type is (S_ENTRY, S_EXIT, S_001_001, S_002_001, S_003_001, S_004_001, S_005_001, S_006_001);
  signal current_state, next_state: state_type;
  signal y0_1_next : std_logic_vector(y'RANGE);
  signal y0_1_reg : std_logic_vector(y'RANGE);
  signal z_1_next : std_logic_vector(y'RANGE);
  signal z_1_reg : std_logic_vector(y'RANGE);
  signal y3_3_next : std_logic_vector(y'RANGE);
  signal y3_3_reg : std_logic_vector(y'RANGE);
  signal i_3_next : std_logic_vector(W-1 downto 0);
  signal i_3_reg : std_logic_vector(W-1 downto 0);
  signal x0_3_next : std_logic_vector(x'RANGE);
  signal x0_3_reg : std_logic_vector(x'RANGE);
  signal t2_3_next : std_logic_vector(x'RANGE);
  signal t2_3_reg : std_logic_vector(x'RANGE);
  signal x0_1_next : std_logic_vector(x'RANGE);
  signal x0_1_reg : std_logic_vector(x'RANGE);
  signal i_1_next : std_logic_vector(W-1 downto 0);
  signal i_1_reg : std_logic_vector(W-1 downto 0);
  signal x0_2_next : std_logic_vector(x'RANGE);
  signal x0_2_reg : std_logic_vector(x'RANGE);
  signal y0_2_next : std_logic_vector(y'RANGE);
  signal y0_2_reg : std_logic_vector(y'RANGE);
  signal i_2_next : std_logic_vector(W-1 downto 0);
  signal i_2_reg : std_logic_vector(W-1 downto 0);
  signal q0_8_next : std_logic_vector(q'RANGE);
  signal q0_8_reg : std_logic_vector(q'RANGE);
  signal q0_5_next : std_logic_vector(q'RANGE);
  signal q0_5_reg : std_logic_vector(q'RANGE);
  signal x0_4_next : std_logic_vector(x'RANGE);
  signal x0_4_reg : std_logic_vector(x'RANGE);
  signal y0_4_next : std_logic_vector(y'RANGE);
  signal y0_4_reg : std_logic_vector(y'RANGE);
  signal q0_7_next : std_logic_vector(q'RANGE);
  signal q0_7_reg : std_logic_vector(q'RANGE);
  signal y1_4_next : std_logic_vector(y'RANGE);
  signal y1_4_reg : std_logic_vector(y'RANGE);
  signal x1_3_next : std_logic_vector(x'RANGE);
  signal x1_3_reg : std_logic_vector(x'RANGE);
  signal y0_3_next : std_logic_vector(y'RANGE);
  signal y0_3_reg : std_logic_vector(y'RANGE);
  signal y2_3_next : std_logic_vector(y'RANGE);
  signal y2_3_reg : std_logic_vector(y'RANGE);
  signal s_4_next : std_logic_vector(y'RANGE);
  signal s_4_reg : std_logic_vector(y'RANGE);
  signal u_4_next : std_logic_vector(x'RANGE);
  signal u_4_reg : std_logic_vector(x'RANGE);
  signal t_3_next : std_logic_vector(x'RANGE);
  signal t_3_reg : std_logic_vector(x'RANGE);
  signal x3_3_next : std_logic_vector(x'RANGE);
  signal x3_3_reg : std_logic_vector(x'RANGE);
  signal t0_3_next : std_logic_vector(x'RANGE);
  signal t0_3_reg : std_logic_vector(x'RANGE);
  signal t1_3_next : std_logic_vector(x'RANGE);
  signal t1_3_reg : std_logic_vector(x'RANGE);
  signal y4_4_next : std_logic_vector(y'RANGE);
  signal y4_4_reg : std_logic_vector(y'RANGE);
  signal q_next : std_logic_vector(q'RANGE);
  signal q_reg : std_logic_vector(q'RANGE);
  constant CNST_W : std_logic_vector(W-1 downto 0) := std_logic_vector(to_unsigned(x'LEFT-x'RIGHT+1,W));
  constant CNST_1 : std_logic_vector(W-1 downto 0) := std_logic_vector(to_unsigned(1,W));
  constant CNST_0 : std_logic_vector(W-1 downto 0) := std_logic_vector(to_unsigned(0,W));
begin
  -- current state logic
  process (clk, reset)
  begin
    if (reset = '1') then
      current_state <= S_ENTRY;
      y0_1_reg <= (others => '0');
      z_1_reg <= (others => '0');
      y3_3_reg <= (others => '0');
      i_3_reg <= (others => '0');
      x0_3_reg <= (others => '0');
      t2_3_reg <= (others => '0');
      x0_1_reg <= (others => '0');
      i_1_reg <= (others => '0');
      x0_2_reg <= (others => '0');
      y0_2_reg <= (others => '0');
      i_2_reg <= (others => '0');
      q0_8_reg <= (others => '0');
      q0_5_reg <= (others => '0');
      x0_4_reg <= (others => '0');
      y0_4_reg <= (others => '0');
      q0_7_reg <= (others => '0');
      y1_4_reg <= (others => '0');
      x1_3_reg <= (others => '0');
      y0_3_reg <= (others => '0');
      y2_3_reg <= (others => '0');
      s_4_reg <= (others => '0');
      u_4_reg <= (others => '0');
      t_3_reg <= (others => '0');
      x3_3_reg <= (others => '0');
      t0_3_reg <= (others => '0');
      t1_3_reg <= (others => '0');
      y4_4_reg <= (others => '0');
      q_reg <= (others => '0');
    elsif (clk = '1' and clk'EVENT) then
      current_state <= next_state;
      y0_1_reg <= y0_1_next;
      z_1_reg <= z_1_next;
      y3_3_reg <= y3_3_next;
      i_3_reg <= i_3_next;
      x0_3_reg <= x0_3_next;
      t2_3_reg <= t2_3_next;
      x0_1_reg <= x0_1_next;
      i_1_reg <= i_1_next;
      x0_2_reg <= x0_2_next;
      y0_2_reg <= y0_2_next;
      i_2_reg <= i_2_next;
      q0_8_reg <= q0_8_next;
      q0_5_reg <= q0_5_next;
      x0_4_reg <= x0_4_next;
      y0_4_reg <= y0_4_next;
      q0_7_reg <= q0_7_next;
      y1_4_reg <= y1_4_next;
      x1_3_reg <= x1_3_next;
      y0_3_reg <= y0_3_next;
      y2_3_reg <= y2_3_next;
      s_4_reg <= s_4_next;
      u_4_reg <= u_4_next;
      t_3_reg <= t_3_next;
      x3_3_reg <= x3_3_next;
      t0_3_reg <= t0_3_next;
      t1_3_reg <= t1_3_next;
      y4_4_reg <= y4_4_next;
      q_reg <= q_next;
    end if;
  end process;

  -- next state and output logic
  process (current_state, start,
    x, y, q_reg, 
    y0_1_reg, y0_1_next, z_1_reg, z_1_next,
    y3_3_reg, y3_3_next, i_3_reg, i_3_next,
    x0_3_reg, x0_3_next, t2_3_reg, t2_3_next,
    x0_1_reg, x0_1_next, i_1_reg, i_1_next,
    x0_2_reg, x0_2_next, y0_2_reg, y0_2_next,
    i_2_reg, i_2_next, q0_8_reg, q0_8_next,
    q0_5_reg, q0_5_next, x0_4_reg, x0_4_next,
    y0_4_reg, y0_4_next, q0_7_reg, q0_7_next,
    y1_4_reg, y1_4_next,
    x1_3_reg, x1_3_next, y0_3_reg, y0_3_next,
    y2_3_reg, y2_3_next, s_4_reg, s_4_next,
    u_4_reg, u_4_next, t_3_reg, t_3_next,
    x3_3_reg, x3_3_next, t0_3_reg, t0_3_next,
    t1_3_reg, t1_3_next, y4_4_reg, y4_4_next
  )
  begin
    done <= '0';
    ready <= '0';
    y0_1_next <= y0_1_reg;
    z_1_next <= z_1_reg;
    y3_3_next <= y3_3_reg;
    i_3_next <= i_3_reg;
    x0_3_next <= x0_3_reg;
    t2_3_next <= t2_3_reg;
    x0_1_next <= x0_1_reg;
    i_1_next <= i_1_reg;
    x0_2_next <= x0_2_reg;
    y0_2_next <= y0_2_reg;
    i_2_next <= i_2_reg;
    q0_8_next <= q0_8_reg;
    q0_5_next <= q0_5_reg;
    x0_4_next <= x0_4_reg;
    y0_4_next <= y0_4_reg;
    q0_7_next <= q0_7_reg;
    y1_4_next <= y1_4_reg;
    x1_3_next <= x1_3_reg;
    y0_3_next <= y0_3_reg;
    y2_3_next <= y2_3_reg;
    s_4_next <= s_4_reg;
    u_4_next <= u_4_reg;
    t_3_next <= t_3_reg;
    x3_3_next <= x3_3_reg;
    t0_3_next <= t0_3_reg;
    t1_3_next <= t1_3_reg;
    y4_4_next <= y4_4_reg;
    q_next <= q_reg;
    case current_state is
      when S_ENTRY =>
        ready <= '1';
        if (start = '1') then
          next_state <= S_001_001;
        else
          next_state <= S_ENTRY;
        end if;
      when S_001_001 =>
        if (x(x'LEFT) = '1') then
          y0_1_next <= std_logic_vector(not(unsigned(x)) + unsigned(ONE));
        else
          y0_1_next <= x;
        end if;
        if (y(y'LEFT) = '1') then
          z_1_next <= std_logic_vector(not(unsigned(y)) + unsigned(ONE));
        else
          z_1_next <= y;
        end if;
        x0_1_next <= CNST_0(x'RANGE);
        i_1_next <= CNST_0;
        x0_2_next <= x0_1_next;
        y0_2_next <= y0_1_next;
        i_2_next <= i_1_next;
        next_state <= S_002_001; 
      when S_002_001 =>
        i_3_next <= std_logic_vector(signed(i_2_reg) + signed(CNST_1));
        x1_3_next <= x0_2_reg(x'LEFT-1 downto 0) & (0 downto 0 => '0');
        y0_3_next <= y0_2_reg(y'LEFT-1 downto 0) & (0 downto 0 => '0');
        y2_3_next <= (y'LEFT-1 downto 0 => '0') & y0_2_reg(y'LEFT downto y'LEFT);
        t0_3_next <= x0_2_reg;
        y3_3_next <= std_logic_vector(unsigned(y0_3_next) + unsigned(CNST_1(y'RANGE)));
        x0_3_next <= x1_3_next or y2_3_next;
        i_2_next <= i_3_next;
        t_3_next(x'LEFT downto 1) <= (others => t0_3_next(x'LEFT));
        t_3_next(0 downto 0) <= t0_3_next(x'LEFT downto x'LEFT);
        x3_3_next <= std_logic_vector(unsigned(x0_3_next) - unsigned(z_1_reg));
        t1_3_next <= t_3_next;
        t2_3_next <= x0_3_next or t1_3_next;
        if (t2_3_next >= z_1_reg) then
          x0_4_next <= x3_3_next;
        else
          x0_4_next <= x0_3_next;
        end if;
        if (t2_3_next >= z_1_reg) then
          y0_4_next <= y3_3_next;
        else 
          y0_4_next <= y0_3_next;
        end if;
        x0_2_next <= x0_4_next;
        y0_2_next <= y0_4_next;
        if (signed(i_3_next) < signed(CNST_W)) then
          next_state <= S_002_001;
        else
          next_state <= S_003_001;
        end if;
      when S_003_001 =>
        y1_4_next <= std_logic_vector(not(unsigned(y0_4_reg)) + unsigned(ONE));
        s_4_next(y'LEFT downto 1) <= (others => y(y'LEFT));
        s_4_next(0 downto 0) <= y(y'LEFT downto y'LEFT);
        u_4_next(x'LEFT downto 1) <= (others => x(x'LEFT));
        u_4_next(0 downto 0) <= x(x'LEFT downto x'LEFT);
        y4_4_next <= y0_4_reg;
        if (u_4_next  /= CNST_0(x'RANGE)) then
          next_state <= S_004_001;
        else
          next_state <= S_005_001;
        end if;
      when S_004_001 =>
        if (s_4_reg = CNST_0(y'RANGE)) then
          q0_5_next <= y1_4_reg;
        else
          q0_5_next <= y4_4_reg;
        end if;
        q0_8_next <= q0_5_next;
        next_state <= S_006_001;
      when S_005_001 =>
        if (s_4_reg /= CNST_0(y'RANGE)) then
          q0_7_next <= y1_4_reg;
        else
          q0_7_next <= y4_4_reg;
        end if;
        q0_8_next <= q0_7_next;
        next_state <= S_006_001;
      when S_006_001 =>       
        q_next <= q0_8_reg;
        next_state <= S_EXIT;
      when S_EXIT =>        
        done <= '1';
        next_state <= S_ENTRY;
      when others =>
        next_state <= S_ENTRY;
    end case;
  end process;
  q <= q_reg;
end fsmd;
