-- File automatically generated by "cdfg2hdl".
-- Filename: divu.vhd
-- Date: 28 September 2011 03:04:34 PM
-- Author: Nikolaos Kavvadias (C) 2009, 2010, 2011
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity divu is
  generic (
    W     : integer := 32
  );
  port (
    clk   : in  std_logic;
    reset : in  std_logic;
    start : in  std_logic;
    x     : in  std_logic_vector;
    y     : in  std_logic_vector;
    q     : out std_logic_vector;
    done  : out std_logic;
    ready : out std_logic
  );
end divu;

architecture fsmd of divu is
  type state_type is (S_ENTRY, S_EXIT, S_001_001, S_002_001, S_003_001);
  signal current_state, next_state: state_type;
  signal y3_3_next : std_logic_vector(y'RANGE);
  signal y3_3_reg : std_logic_vector(y'RANGE);
  signal i_3_next : std_logic_vector(W-1 downto 0);
  signal i_3_reg : std_logic_vector(W-1 downto 0);
  signal x0_3_next : std_logic_vector(x'RANGE);
  signal x0_3_reg : std_logic_vector(x'RANGE);
  signal t2_3_next : std_logic_vector(x'RANGE);
  signal t2_3_reg : std_logic_vector(x'RANGE);
  signal x0_1_next : std_logic_vector(x'RANGE);
  signal x0_1_reg : std_logic_vector(x'RANGE);
  signal i_1_next : std_logic_vector(W-1 downto 0);
  signal i_1_reg : std_logic_vector(W-1 downto 0);
  signal y0_1_next : std_logic_vector(y'RANGE);
  signal y0_1_reg : std_logic_vector(y'RANGE);
  signal x0_2_next : std_logic_vector(x'RANGE);
  signal x0_2_reg : std_logic_vector(x'RANGE);
  signal y0_2_next : std_logic_vector(y'RANGE);
  signal y0_2_reg : std_logic_vector(y'RANGE);
  signal i_2_next : std_logic_vector(W-1 downto 0);
  signal i_2_reg : std_logic_vector(W-1 downto 0);
  signal z_1_next : std_logic_vector(y'RANGE);
  signal z_1_reg : std_logic_vector(y'RANGE);
  signal x0_4_next : std_logic_vector(x'RANGE);
  signal x0_4_reg : std_logic_vector(x'RANGE);
  signal y0_4_next : std_logic_vector(y'RANGE);
  signal y0_4_reg : std_logic_vector(y'RANGE);
  signal x1_3_next : std_logic_vector(x'RANGE);
  signal x1_3_reg : std_logic_vector(x'RANGE);
  signal y0_3_next : std_logic_vector(y'RANGE);
  signal y0_3_reg : std_logic_vector(y'RANGE);
  signal y2_3_next : std_logic_vector(y'RANGE);
  signal y2_3_reg : std_logic_vector(y'RANGE);
  signal t_3_next : std_logic_vector(x'RANGE);
  signal t_3_reg : std_logic_vector(x'RANGE);
  signal x3_3_next : std_logic_vector(x'RANGE);
  signal x3_3_reg : std_logic_vector(x'RANGE);
  signal t0_3_next : std_logic_vector(x'RANGE);
  signal t0_3_reg : std_logic_vector(x'RANGE);
  signal t1_3_next : std_logic_vector(x'RANGE);
  signal t1_3_reg : std_logic_vector(x'RANGE);
  signal q_next : std_logic_vector(q'RANGE);
  signal q_reg : std_logic_vector(q'RANGE);
  constant CNST_W : std_logic_vector(W-1 downto 0) := std_logic_vector(to_unsigned(x'LEFT-x'RIGHT+1,W));
  constant CNST_1 : std_logic_vector(W-1 downto 0) := std_logic_vector(to_unsigned(1,W));
  constant CNST_0 : std_logic_vector(W-1 downto 0) := std_logic_vector(to_unsigned(0,W));
begin
  -- current state logic
  process (clk, reset)
  begin
    if (reset = '1') then
      current_state <= S_ENTRY;
      y3_3_reg <= (others => '0');
      i_3_reg <= (others => '0');
      x0_3_reg <= (others => '0');
      t2_3_reg <= (others => '0');
      x0_1_reg <= (others => '0');
      i_1_reg <= (others => '0');
      y0_1_reg <= (others => '0');
      x0_2_reg <= (others => '0');
      y0_2_reg <= (others => '0');
      i_2_reg <= (others => '0');
      z_1_reg <= (others => '0');
      x0_4_reg <= (others => '0');
      y0_4_reg <= (others => '0');
      x1_3_reg <= (others => '0');
      y0_3_reg <= (others => '0');
      y2_3_reg <= (others => '0');
      t_3_reg <= (others => '0');
      x3_3_reg <= (others => '0');
      t0_3_reg <= (others => '0');
      t1_3_reg <= (others => '0');
      q_reg <= (others => '0');
    elsif (clk = '1' and clk'EVENT) then
      current_state <= next_state;
      y3_3_reg <= y3_3_next;
      i_3_reg <= i_3_next;
      x0_3_reg <= x0_3_next;
      t2_3_reg <= t2_3_next;
      x0_1_reg <= x0_1_next;
      i_1_reg <= i_1_next;
      y0_1_reg <= y0_1_next;
      x0_2_reg <= x0_2_next;
      y0_2_reg <= y0_2_next;
      i_2_reg <= i_2_next;
      z_1_reg <= z_1_next;
      x0_4_reg <= x0_4_next;
      y0_4_reg <= y0_4_next;
      x1_3_reg <= x1_3_next;
      y0_3_reg <= y0_3_next;
      y2_3_reg <= y2_3_next;
      t_3_reg <= t_3_next;
      x3_3_reg <= x3_3_next;
      t0_3_reg <= t0_3_next;
      t1_3_reg <= t1_3_next;
      q_reg <= q_next;
    end if;
  end process;

  -- next state and output logic
  process (current_state, start,
    x, y, q_reg, 
    y3_3_reg, y3_3_next, i_3_reg, i_3_next,
    x0_3_reg, x0_3_next, t2_3_reg, t2_3_next,
    x0_1_reg, x0_1_next, i_1_reg, i_1_next,
    y0_1_reg, y0_1_next, x0_2_reg, x0_2_next,
    y0_2_reg, y0_2_next, i_2_reg, i_2_next,
    z_1_reg, z_1_next, x0_4_reg, x0_4_next,
    y0_4_reg, y0_4_next, x1_3_reg, x1_3_next,
    y0_3_reg, y0_3_next, y2_3_reg, y2_3_next,
    t_3_reg, t_3_next, x3_3_reg, x3_3_next,
    t0_3_reg, t0_3_next, t1_3_reg, t1_3_next
  )
  begin
    done <= '0';
    ready <= '0';
    y3_3_next <= y3_3_reg;
    i_3_next <= i_3_reg;
    x0_3_next <= x0_3_reg;
    t2_3_next <= t2_3_reg;
    x0_1_next <= x0_1_reg;
    i_1_next <= i_1_reg;
    y0_1_next <= y0_1_reg;
    x0_2_next <= x0_2_reg;
    y0_2_next <= y0_2_reg;
    i_2_next <= i_2_reg;
    z_1_next <= z_1_reg;
    x0_4_next <= x0_4_reg;
    y0_4_next <= y0_4_reg;
    x1_3_next <= x1_3_reg;
    y0_3_next <= y0_3_reg;
    y2_3_next <= y2_3_reg;
    t_3_next <= t_3_reg;
    x3_3_next <= x3_3_reg;
    t0_3_next <= t0_3_reg;
    t1_3_next <= t1_3_reg;
    q_next <= q_reg;
    case current_state is
      when S_ENTRY =>
        ready <= '1';
        if (start = '1') then
          next_state <= S_001_001;
        else
          next_state <= S_ENTRY;
        end if;
      when S_001_001 =>
        x0_1_next  <= CNST_0(x'RANGE);
        i_1_next   <= CNST_0;
        y0_1_next  <= x;
        z_1_next   <= y;
        x0_2_next  <= x0_1_next;
        y0_2_next  <= y0_1_next;
        i_2_next   <= i_1_next;
        next_state <= S_002_001; 
      when S_002_001 =>        
        i_3_next <= std_logic_vector(signed(i_2_reg) + signed(CNST_1));
        x1_3_next <= x0_2_reg(x0_2_reg'LEFT-1 downto 0) & (0 downto 0 => '0');
        y0_3_next <= y0_2_reg(y0_2_reg'LEFT-1 downto 0) & (0 downto 0 => '0');
        y2_3_next <= (y0_2_reg'LEFT-1 downto 0 => '0') & y0_2_reg(y0_2_reg'LEFT downto y0_2_reg'LEFT);
        t0_3_next <= x0_2_reg;
        y3_3_next <= std_logic_vector(unsigned(y0_3_next) + unsigned(CNST_1(y0_3_next'RANGE)));
        x0_3_next <= x1_3_next or y2_3_next;
        i_2_next <= i_3_next;
        t_3_next(t_3_next'LEFT downto 1) <= (others => t0_3_next(t0_3_next'LEFT));
        t_3_next(0 downto 0) <= t0_3_next(t0_3_next'LEFT downto t0_3_next'LEFT);
        x3_3_next <= std_logic_vector(unsigned(x0_3_next) - unsigned(z_1_reg));
        t1_3_next(t1_3_next'LEFT downto 0) <= t_3_next;
        t2_3_next <= x0_3_next or t1_3_next;
        if (t2_3_next >= z_1_reg) then
          x0_4_next <= x3_3_next;
        else
          x0_4_next <= x0_3_next;
        end if;
        if (t2_3_next  >= z_1_reg) then
          y0_4_next <= y3_3_next;
        else
          y0_4_next <= y0_3_next;
        end if;
        x0_2_next <= x0_4_next;
        y0_2_next <= y0_4_next;
        if (signed(i_3_next) < signed(CNST_W)) then
          next_state <= S_002_001;
        else
          next_state <= S_003_001;
        end if;
      when S_003_001 =>
        q_next <= y0_4_reg;
        next_state <= S_EXIT; 
      when S_EXIT =>        
        done <= '1';
        next_state <= S_ENTRY;
    end case;
  end process;
  q <= q_reg;
end fsmd;
